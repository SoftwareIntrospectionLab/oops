dir,file,loop,count,content
bind/lib/bind9,check.c,while,3,while (acls[i] != ((void *)0)) {>>>} while (sources[++source].v4 != ((void *)0));>>>while ((e2 = cfg_list_next(e2)) != ((void *)0)) {
bind/lib/bind9,check.c,for,42,for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(dns64);>>>for (i = 0; acls[i] != ((void *)0); i++) {>>>for (i = 0; acls[i] != ((void *)0); i++) {>>>for (i = 0; i < sizeof(intervals) / sizeof(intervals[0]); i++) {>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (i= 0; server_contact[i] != ((void *)0); i++) {>>>for (element = cfg_list_first(obj);>>>for (elt = cfg_list_first(masters);>>>for (element = cfg_list_first(policy);>>>for (element2 = cfg_list_first(typelist);>>>for (i = 0; i < sizeof(options) / sizeof(options[0]); i++) {>>>for (element = cfg_list_first(obj);>>>for (element = cfg_list_first(obj);>>>for (i = 0; algorithms[i].name != ((void *)0); i++) {>>>for (element = cfg_list_first(keys);>>>for (element = cfg_list_first(keylist);>>>for (e1 = cfg_list_first(servers); e1 != ((void *)0); e1 = cfg_list_next(e1)) {>>>for (element = cfg_list_first(zones);>>>for (element = cfg_list_first(keys);>>>for (element2 = cfg_list_first(keylist);>>>for (element = cfg_list_first(keys);>>>for (element2 = cfg_list_first(keylist);>>>for (i = 0; default_channels[i] != ((void *)0); i++) {>>>for (element = cfg_list_first(channels);>>>for (element = cfg_list_first(categories);>>>for (delement = cfg_list_first(channels);>>>for (element = cfg_list_first(control_keylist);>>>for (element = cfg_list_first(controlslist);>>>for (element2 = cfg_list_first(inetcontrols);>>>for (element2 = cfg_list_first(unixcontrols);>>>for (i = 0; i < 3; i++) {>>>for (velement = cfg_list_first(views);>>>for (elt = cfg_list_first(acls);>>>for (elt2 = cfg_list_next(elt);>>>for (elt = cfg_list_first(kals);>>>for (elt2 = cfg_list_next(elt);
bind/lib/bind9,getaddresses.c,for,1,for (i = 0; i < addrsize; i++) {
bind/lib/dns,acache.c,while,6,while ((dbent = ISC_LIST_HEAD(acache->dbbucket[i])) != NULL) {>>>while (n_entries-- > 0) {>>>while (i-- > 0)>>>while ((entry = ISC_LIST_HEAD(dbentry->originlist)) != NULL) {>>>while ((entry = ISC_LIST_HEAD(dbentry->referlist)) != NULL) {>>>while ((erdataset = ISC_LIST_HEAD(fname->list)) != NULL) {
bind/lib/dns,acache.c,for,10,for (entry = ISC_LIST_HEAD(acache->entries);>>>for (i = 0; i < 67; i++) {>>>for (i = 0; i < 1009; i++)>>>for (dbentry = ISC_LIST_HEAD(acache->dbbucket[bucket]);>>>for (rdataset = ISC_LIST_HEAD(entry->foundname->list);>>>for (i = 0; i < 67; i++)>>>for (i = 0; i < 1009; i++) {>>>for (i = 0; i < 1009; i++)>>>for (erdataset = ISC_LIST_HEAD(entry->foundname->list);>>>for (ardataset = ISC_LIST_HEAD(fname->list);
bind/lib/dns,acl.c,for,4,for (i = 0; i < acl->length; i++) {>>>for (i = 0; i < source->length; i++) {>>>for (i = 0; i < dacl->length; i++) {>>>for (i = 0; i < a->length; i++) {
bind/lib/dns,adb.c,while,41,"while (nbuckets[i] != 0 && adb->nentries >= nbuckets[i])>>>while (e != NULL) {>>>while (e != NULL) {>>>while (nbuckets[i] != 0 && adb->nnames >= nbuckets[i])>>>while (name != NULL) {>>>while (name != NULL) {>>>while (result == ISC_R_SUCCESS) {>>>while (name != NULL) {>>>while (entry != NULL) {>>>while (namehook != NULL) {>>>while (find != NULL) {>>>while (event != NULL) {>>>while (li != NULL) {>>>while (adbname != NULL) {>>>while (li != NULL) {>>>while (namehook != NULL) {>>>while (namehook != NULL) {>>>while (name != NULL) {>>>while (entry != NULL) {>>>do { 		(adb)-> entries = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> entries) * (adb)->nentries); 		if ((adb)-> entries == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> deadentries = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> deadentries) * (adb)->nentries); 		if ((adb)-> deadentries == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> entrylocks = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> entrylocks) * (adb)->nentries); 		if ((adb)-> entrylocks == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> entry_sd = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> entry_sd) * (adb)->nentries); 		if ((adb)-> entry_sd == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> entry_refcnt = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> entry_refcnt) * (adb)->nentries); 		if ((adb)-> entry_refcnt == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> names = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> names) * (adb)->nnames); 		if ((adb)-> names == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> deadnames = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> deadnames) * (adb)->nnames); 		if ((adb)-> deadnames == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> namelocks = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> namelocks) * (adb)->nnames); 		if ((adb)-> namelocks == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> name_sd = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> name_sd) * (adb)->nnames); 		if ((adb)-> name_sd == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 		(adb)-> name_refcnt = isc_mem_get((adb)->mctx, 				     sizeof(*(adb)-> name_refcnt) * (adb)->nnames); 		if ((adb)-> name_refcnt == NULL) { 			result = ISC_R_NOMEMORY; 			goto fail1; 		}	} while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbname_t), &( adb->nmp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->nmp), 64); 	isc_mempool_setfillcount(( adb->nmp), 16); 	isc_mempool_setname(( adb->nmp),  ""adbname""); 	isc_mempool_associatelock(( adb->nmp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbnamehook_t), &( adb->nhmp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->nhmp), 64); 	isc_mempool_setfillcount(( adb->nhmp), 16); 	isc_mempool_setname(( adb->nhmp),  ""adbnamehook""); 	isc_mempool_associatelock(( adb->nhmp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adblameinfo_t), &( adb->limp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->limp), 64); 	isc_mempool_setfillcount(( adb->limp), 16); 	isc_mempool_setname(( adb->limp),  ""adblameinfo""); 	isc_mempool_associatelock(( adb->limp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbentry_t), &( adb->emp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->emp), 64); 	isc_mempool_setfillcount(( adb->emp), 16); 	isc_mempool_setname(( adb->emp),  ""adbentry""); 	isc_mempool_associatelock(( adb->emp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbfind_t), &( adb->ahmp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->ahmp), 64); 	isc_mempool_setfillcount(( adb->ahmp), 16); 	isc_mempool_setname(( adb->ahmp),  ""adbfind""); 	isc_mempool_associatelock(( adb->ahmp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbaddrinfo_t), &( adb->aimp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->aimp), 64); 	isc_mempool_setfillcount(( adb->aimp), 16); 	isc_mempool_setname(( adb->aimp),  ""adbaddrinfo""); 	isc_mempool_associatelock(( adb->aimp), &adb->mplock); } while (0);>>>do { 	result = isc_mempool_create(mem, sizeof(dns_adbfetch_t), &( adb->afmp)); 	if (result != ISC_R_SUCCESS) 		goto fail3; 	isc_mempool_setfreemax(( adb->afmp), 64); 	isc_mempool_setfillcount(( adb->afmp), 16); 	isc_mempool_setname(( adb->afmp),  ""adbfetch""); 	isc_mempool_associatelock(( adb->afmp), &adb->mplock); } while (0);>>>while (ai != NULL) {>>>while (entry != NULL) {>>>while (ai != NULL) {>>>while (find != NULL) {>>>while (adbname != NULL) {"
bind/lib/dns,adb.c,for,25,for (i = 0; i < adb->nentries; i++)>>>for (i = 0; i < n; i++) {>>>for (i = 0; i < adb->nentries; i++) {>>>for (i = 0; i < adb->nnames; i++)>>>for (i = 0; i < n; i++) {>>>for (i = 0; i < adb->nnames; i++) {>>>for (anh = ISC_LIST_HEAD(*hookhead);>>>for (i = 0; i < 2; i++) {>>>for (bucket = 0; bucket < adb->nnames; bucket++) {>>>for (bucket = 0; bucket < adb->nentries; bucket++) {>>>for (entry = ISC_LIST_HEAD(adb->entries[bucket]);>>>for (i = 0; i < adb->nnames; i++) {>>>for (i = 0; i < adb->nentries; i++) {>>>for (i = 0; i < adb->nnames; i++)>>>for (i = 0; i < adb->nentries; i++)>>>for (i = 0; i < adb->nnames; i++)>>>for (i = 0; i < adb->nentries; i++)>>>for (i = 0; i < adb->nnames; i++) {>>>for (i = 0; i < adb->nentries; i++) {>>>for (i = 0; i < adb->nentries; i++)>>>for (i = 0; i < adb->nnames; i++)>>>for (li = ISC_LIST_HEAD(entry->lameinfo);>>>for (nh = ISC_LIST_HEAD(*list);>>>for (i = 0; i < adb->nnames; i++)>>>for (i = 0; i < adb->nentries; i++)
bind/lib/dns,byaddr.c,for,1,for (i = 15; i >= 0; i--) {
bind/lib/dns,cache.c,while,3,while (n_names-- > 0) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {
bind/lib/dns,cache.c,for,5,for (i = 0; i < cache->db_argc; i++)>>>for (i = extra; i < cache->db_argc; i++) {>>>for (i = extra; i < cache->db_argc; i++)>>>for (i = extra; i < cache->db_argc; i++)>>>for (result = dns_rdatasetiter_first(iter);
bind/lib/dns,client.c,while,12,while ((view = ISC_LIST_HEAD(client->viewlist)) != ((void *)0)) {>>>while (tresult == ISC_R_SUCCESS) {>>>while ((rdataset = ISC_LIST_HEAD(ansname->list))>>>} while (want_restart);>>>while ((name = ISC_LIST_HEAD(rctx->namelist)) != ((void *)0)) {>>>while ((name = ISC_LIST_HEAD(rev->answerlist)) != ((void *)0)) {>>>while ((name = ISC_LIST_HEAD(*namelist)) != ((void *)0)) {>>>while ((rdataset = ISC_LIST_HEAD(name->list)) != ((void *)0)) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while ((sa = ISC_LIST_HEAD(uctx->servers)) != ((void *)0)) {>>>while ((sa = ISC_LIST_HEAD(uctx->servers)) != ((void *)0)) {
bind/lib/dns,client.c,for,11,for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list); rdataset != ((void *)0);>>>for (server = ISC_LIST_HEAD(*servers);>>>for (name = ISC_LIST_HEAD(*prerequisites); name != ((void *)0);>>>for (name = ISC_LIST_HEAD(*updates); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdata = ISC_LIST_HEAD(rdatalist->rdata);
bind/lib/dns,compress.c,while,4,while (cctx->table[i] != NULL) {>>>do { 	( &nname)->length = (node)->r.length; 	( &nname)->labels = (node)->labels; 	( &nname)->ndata = (node)->r.base; 	( &nname)->attributes = DNS_NAMEATTR_ABSOLUTE; } while (0);>>>while (count > 0) {>>>while (node != NULL && node->offset >= offset) {
bind/lib/dns,compress.c,for,5,for (i = 0; i < DNS_COMPRESS_TABLESIZE; i++)>>>for (i = 0; i < DNS_COMPRESS_TABLESIZE; i++) {>>>for (n = 0; n < labels - 1; n++) {>>>for (node = cctx->table[hash]; node != NULL; node = node->next)>>>for (i = 0; i < DNS_COMPRESS_TABLESIZE; i++) {
bind/lib/dns,db.c,for,1,for (imp = ISC_LIST_HEAD(implementations);
bind/lib/dns,diff.c,while,14,"while ((t = ISC_LIST_HEAD(diff->tuples)) != ((void *)0)) {>>>while (result == ISC_R_SUCCESS) {>>>while (t != ((void *)0)) {>>>while (t != ((void *)0) && dns_name_equal(&t->name, name)) {>>>do { result = (dns_db_findnode(db, name, ISC_TRUE, 						      &node));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_findnsec3node(db, name, ISC_TRUE, 							   &node));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>while (t != ((void *)0) &&>>>do { result = (dns_rdatalist_tordataset(&rdl, &rds));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (result);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>while (t != ((void *)0)) {>>>while (t != ((void *)0) && dns_name_equal(&t->name, name)) {>>>while (t != ((void *)0) && dns_name_equal(&t->name, name) &&>>>do { result = (dns_rdatalist_tordataset(&rdl, &rds));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (result);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);"
bind/lib/dns,diff.c,for,5,for (ot = ISC_LIST_HEAD(diff->tuples); ot != ((void *)0);>>>for (p = ISC_LIST_HEAD(diff->tuples);>>>for (i = 0; i < length; i++) {>>>for (i = 0; i < length; i++) {>>>for (t = ISC_LIST_HEAD(diff->tuples); t != ((void *)0);
bind/lib/dns,dispatch.c,while,10,while (bucket < qid->qid_nbuckets) {>>>while (bucket < qid->qid_nbuckets) {>>>while ((dispsocket = ISC_LIST_HEAD(disp->inactivesockets)) != ((void *)0)) {>>>while (portentry != ((void *)0)) {>>>while (dispsock != ((void *)0)) {>>>while (res != ((void *)0)) {>>>} while (p++ < 65535);>>>while (disp != ((void *)0)) {>>>while (--i >= 0) {>>>while (ev != ((void *)0)) {
bind/lib/dns,dispatch.c,for,15,for (;;) {>>>for (i = 0; i < disp->ntasks; i++)>>>for (i = 0; i < 64; i++) {>>>for (i = 0; i < buckets; i++) {>>>for (i = 0; i < 1024; i++)>>>for (i = 0; i < 1024; i++) {>>>for (j = 0; j < 0xffffU; j++) {>>>for (i = 0; i < 20U; i++) {>>>for (i = 0; i < 1024; i++)>>>for (i = 0; i < disp->ntasks; i++) {>>>for (i = 0; i < disp->ntasks; i++)>>>for (dispsock = ISC_LIST_HEAD(disp->activesockets);>>>for (i = 0; i < 64; i++) {>>>for (dispsock = ISC_LIST_HEAD(disp->activesockets);>>>for (resp = linear_first(qid);
bind/lib/dns,dlz.c,while,4,while (*s == ' ' || *s == '\t')>>>while (*p != ' ' && *p != '\t' && *p != '\0' && *p != '{') {>>>while (*t != '\0') {>>>while (*p != '\0' && *p != '}') {
bind/lib/dns,dlz.c,for,2,for (imp = ISC_LIST_HEAD(dlz_implementations);>>>for (i = namelabels; i > minlabels && i > 1; i--) {
bind/lib/dns,dns64.c,for,6,"for (i = 0; i < 4U; i++) {>>>for (;dns64 != NULL; dns64 = ISC_LIST_NEXT(dns64, link)) {>>>for (i = 0; i < aaaaoklen; i++)>>>for (i = 0; i < aaaaoklen; i++)>>>for (result = dns_rdataset_first(rdataset);>>>for (i = 0; i < aaaaoklen; i++)"
bind/lib/dns,dnssec.c,while,46,"} while (dns_rdataset_next(&rdataset) == ISC_R_SUCCESS);>>>do { 	result = (dns_db_findrdataset(db, node, ver, dns_rdatatype_dnskey, 0, 0, 				   &rdataset, ((void *)0))); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdataset_first(&rdataset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS && count < maxkeys) {>>>do { 	result = (dns_dnssec_keyfromrdata(name, &rdata, mctx, &pubkey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (count > 0)>>>do { 	result = (dst_context_create(key, mctx, &ctx)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(((void *)0), dns_rdataclass_any, 				    dns_rdatatype_sig , 				    &sig, &databuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &msg->query)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_sigsize(key, &sigsize)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_sign(ctx, &sigbuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdata(msg, &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(msg->mctx, &dynbuf, 1024)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(rdata, dns_rdataclass_any, 				    dns_rdatatype_sig , 				    &sig, dynbuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdatalist(msg, &datalist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdataset(msg, &dataset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdataset_first(msg->sig0)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata, &sig, ((void *)0))); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_create(key, mctx, &ctx)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &msg->query)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &header_r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_context_adddata(ctx, &r)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_name_tofilenametext(origin, ISC_FALSE, &b)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_dir_open(&dir, directory)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (isc_dir_read(&dir) == ISC_R_SUCCESS) {>>>do { 	result = (dns_dnsseckey_create(mctx, &dstkey, &key)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while ((key = ISC_LIST_HEAD(list)) != ((void *)0)) {>>>do { 	result = (dns_dnssec_keyfromrdata(origin, &rdata, mctx, &pubkey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (result); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (result); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (mark_active_keys(keylist, keysigs)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (mark_active_keys(keylist, soasigs)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (make_dnskey(key->key, buf, sizeof(buf), &dnskey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(mctx, DNS_DIFFOP_ADD, origin, ttl, 				    &dnskey, &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (make_dnskey(key->key, buf, sizeof(buf), &dnskey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(mctx, DNS_DIFFOP_DEL, origin, ttl, &dnskey, 				    &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (publish_key(diff, key, origin, ttl, 					   mctx, allzsk, report)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (publish_key(diff, key1, origin, ttl, 						   mctx, allzsk, report)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (remove_key(diff, key2, origin, ttl, mctx, 					  ""expired"", report)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (remove_key(diff, key2, origin, ttl, mctx, 					  ""revoked"", report)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (publish_key(diff, key1, origin, ttl, 					   mctx, allzsk, report)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (!ISC_LIST_EMPTY(*newkeys)) {"
bind/lib/dns,dnssec.c,for,11,for (i = 0; i < nrdatas; i++) {>>>for (i = 0; i < nrdatas; i++) {>>>for (result = dns_rdataset_first(sigrdataset);>>>for (key = ISC_LIST_HEAD(*keylist);>>>for (key = ISC_LIST_HEAD(*keylist);>>>for (result = dns_rdataset_first(&sigs);>>>for (result = dns_rdataset_first(&keys);>>>for (key = ISC_LIST_HEAD(*keys);>>>for (key = ISC_LIST_HEAD(*newkeys);>>>for (key1 = ISC_LIST_HEAD(*newkeys); key1 != ((void *)0); key1 = next) {>>>for (key2 = ISC_LIST_HEAD(*keys);
bind/lib/dns,dst_api.c,while,29,"do {							result = (dst__hmacmd5_init(&dst_t_func[DST_ALG_HMACMD5]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (dst__hmacsha1_init(&dst_t_func[DST_ALG_HMACSHA1]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (dst__hmacsha224_init(&dst_t_func[DST_ALG_HMACSHA224]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (dst__hmacsha256_init(&dst_t_func[DST_ALG_HMACSHA256]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (dst__hmacsha384_init(&dst_t_func[DST_ALG_HMACSHA384]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (dst__hmacsha512_init(&dst_t_func[DST_ALG_HMACSHA512]));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							isc_result_t _r;				_r = algorithm_status(key->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(dctx->key->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(pub->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(priv->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(key->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							result = (DST_R_UNSUPPORTEDALG);					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (ISC_R_NOMEMORY);					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_lex_create(mctx, 1500, &lex));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_lex_openfile(lex, newfilename));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (key->func->parse(key, lex, pubkey));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (computeid(key));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (DST_R_INVALIDPRIVATEKEY);					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							isc_result_t _r;				_r = algorithm_status(key->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(key->key_alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							result = (DST_R_UNSUPPORTEDALG);					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_lex_create(key->mctx, 1500, &lex));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_lex_openbuffer(lex, buffer));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (key->func->parse(key, lex, ((void *)0)));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_buffer_allocate(key->mctx, &key->key_tkeytoken, 		       intoken->length));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							result = (isc_buffer_copyregion(key->key_tkeytoken, intoken));					if (result != ISC_R_SUCCESS)				goto out;			} while (0);>>>do {							isc_result_t _r;				_r = algorithm_status(alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;>>>do {							isc_result_t _r;				_r = algorithm_status(alg);			if (_r != ISC_R_SUCCESS)				return (_r);			} while (0);;"
bind/lib/dns,dst_api.c,for,2,for (i = 0; i < DST_MAX_ALGS; i++)>>>for (i = 0; i < (DST_MAX_TIMES + 1); i++) {
bind/lib/dns,dst_parse.c,while,10,"do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret == ISC_R_EOF)							break;							else if (ret != ISC_R_SUCCESS)						goto fail;					} while ((* &token).type != isc_tokentype_eol);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt | ISC_LEXOPT_NUMBER,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret == ISC_R_EOF)							break;							else if (ret != ISC_R_SUCCESS)						goto fail;					} while ((* &token).type != isc_tokentype_eol);>>>} while (token.type == isc_tokentype_eol);>>>do {									ret = isc_lex_gettoken(lex,  opt | ISC_LEXOPT_NUMBER,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret != ISC_R_SUCCESS)						goto fail;					} while (0);>>>do {									ret = isc_lex_gettoken(lex,  opt,  &token);			if (ret == ISC_R_EOF)							break;							else if (ret != ISC_R_SUCCESS)						goto fail;					} while ((* &token).type != isc_tokentype_eol);"
bind/lib/dns,dst_parse.c,for,19,for (i = 0; map[i].tag != NULL; i++) {>>>for (i = 0; ; i++) {>>>for (i = 0; i < ntags; i++) {>>>for (i = 0; i < 11; i++)>>>for (j = 0; j < priv->nelements; j++) {>>>for (i = 0; i < 11; i++)>>>for (i = 0; i < 4; i++) {>>>for (j = 0; j < priv->nelements; j++)>>>for (i = 0; i < 5; i++) {>>>for (j = 0; j < priv->nelements; j++)>>>for (i = 0; i < 2; i++) {>>>for (j = 0; j < priv->nelements; j++)>>>for (i = 0; i < ntags; i++) {>>>for (j = 0; j < priv->nelements; j++)>>>for (i = 0; i < priv->nelements; i++) {>>>for (n = 0; n < 12+6; n++) {>>>for (i = 0; i < priv->nelements; i++) {>>>for (i = 0; i < (DST_MAX_NUMERIC + 1); i++) {>>>for (i = 0; i < (DST_MAX_TIMES + 1); i++) {
bind/lib/dns,ecdb.c,while,1,while ((header = ISC_LIST_HEAD(node->rdatasets)) != NULL) {
bind/lib/dns,ecdb.c,for,1,for (header = ISC_LIST_HEAD(ecdbnode->rdatasets); header != NULL;
bind/lib/dns,forward.c,while,2,while (!ISC_LIST_EMPTY(forwarders->addrs)) {>>>while (!ISC_LIST_EMPTY(forwarders->addrs)) {
bind/lib/dns,forward.c,for,1,for (sa = ISC_LIST_HEAD(*addrs);
bind/lib/dns,gen.c,while,16,"while ((c = (*s++) & 0xff))>>>while ((c = *s++)) {>>>while (c > 0) {>>>while ((tt != ((void *)0)) && (tt->type < type)) {>>>while ((tt != ((void *)0)) && (tt->type == type) && (tt->rdclass < rdclass)) {>>>while ((cc != ((void *)0)) && (cc->rdclass < rdclass)) {>>>while (next_file(&dir)) {>>>while ((c = getopt(argc, argv, ""cdits:F:P:S:"")) != -1)>>>while (next_file(&dir)) {>>>fprintf(__stdoutp, ""\t} while (0)\n\n"");>>>do { 		s = funname(""chaos"", buf1); 		classnum =  3; 		fprintf(__stdoutp, ""\tdns_rdataclass_%s = %d%s\n"", s, classnum, 		       classnum != 255 ? "","" : """"); 		fprintf(__stdoutp, ""#define dns_rdataclass_%s\t"" 		       ""((dns_rdataclass_t)dns_rdataclass_%s)\n"", s, s); 	} while (0);>>>do { 		s = funname(""none"", buf1); 		classnum =  254; 		fprintf(__stdoutp, ""\tdns_rdataclass_%s = %d%s\n"", s, classnum, 		       classnum != 255 ? "","" : """"); 		fprintf(__stdoutp, ""#define dns_rdataclass_%s\t"" 		       ""((dns_rdataclass_t)dns_rdataclass_%s)\n"", s, s); 	} while (0);>>>do { 		s = funname(cc->classname, buf1); 		classnum =  cc->rdclass; 		fprintf(__stdoutp, ""\tdns_rdataclass_%s = %d%s\n"", s, classnum, 		       classnum != 255 ? "","" : """"); 		fprintf(__stdoutp, ""#define dns_rdataclass_%s\t"" 		       ""((dns_rdataclass_t)dns_rdataclass_%s)\n"", s, s); 	} while (0);>>>while (fgets(buf, sizeof(buf), fd) != ((void *)0))>>>while (fgets(buf, sizeof(buf), fd) != ((void *)0))>>>while (fgets(buf, sizeof(buf), fd) != ((void *)0))"
bind/lib/dns,gen.c,for,15,for (tt = types; tt != ((void *)0); tt = tt->next) {>>>for (tt = types; tt; tt = tt->next)>>>for (i = 0; i < 256; i++) {>>>for (i = 0; i < 256; i++) {>>>for (i = 0; i < 256; i++)>>>for (tt = types; tt != ((void *)0); tt = tt->next)>>>for (i = 0; i <= maxtype; i++) {>>>for (j = 0; j <= maxtype; j++) {>>>for (i = 0; i <= maxtype; i++) {>>>for (i = 0; i <= maxtype; i++) {>>>for (tt = types; tt != ((void *)0); tt = tt->next)>>>for (tt = types; tt != ((void *)0); tt = tt->next)>>>for (cc = classes; cc != ((void *)0); cc = cc->next) {>>>for (tt = types; tt != ((void *)0); tt = tt->next) {>>>for (tt = types; tt != ((void *)0); tt = tt->next)
bind/lib/dns,hmac_link.c,for,6,for (i = 0; i < priv.nelements && result == ISC_R_SUCCESS; i++) {>>>for (i = 0; i < priv.nelements; i++) {>>>for (i = 0; i < priv.nelements; i++) {>>>for (i = 0; i < priv.nelements; i++) {>>>for (i = 0; i < priv.nelements; i++) {>>>for (i = 0; i < priv.nelements; i++) {
bind/lib/dns,journal.c,while,86,"do { result = (journal_file_create(mctx, filename)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_NOTFOUND);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (journal_seek(j, 0)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_read(j, &rawheader, sizeof(rawheader))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ISC_R_NOMEMORY);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (journal_read(j, j->rawindex, rawbytes)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_NOMEMORY);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>while (k < j->header.index_size) {>>>while (current_pos.serial != serial) {>>>do { result = (journal_seek(j, offset)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(j, &hdr, sizeof(hdr))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(j, used.base, used.length)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, 0)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(j, &rawheader, sizeof(rawheader))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_next(j, &j->header.begin)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, j->x.pos[0].offset)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write_xhdr(j, offset, j->x.pos[0].serial, 					 j->x.pos[1].serial)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, 0)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(j, &rawheader, sizeof(rawheader))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (index_to_disk(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_sort(diff, ixfr_order)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_begin_transaction(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_writediff(j, diff)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_commit(j)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_db_newversion(db, &ver)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_db_getsoaserial(db, ver, &db_serial)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_find(j, db_serial, &pos)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (DNS_R_UPTODATE); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_iter_init(j, db_serial, end_serial)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_difftuple_create(diff.mctx, op, name, ttl, rdata, 					   &tuple)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_apply(&diff, db, ver)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (result); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_apply(&diff, db, ver)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_iter_init(j, start_serial, end_serial)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_difftuple_create(diff.mctx, n_soa == 1 ? 					   DNS_DIFFOP_DEL : DNS_DIFFOP_ADD, 					   name, ttl, rdata, &tuple)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (result); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_find(j, begin_serial, &j->it.bpos)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_find(j, end_serial, &j->it.epos)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, j->it.bpos.offset)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_read_xhdr(j, &xhdr)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (journal_read_rrhdr(j, &rrhdr)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (ISC_R_UNEXPECTED);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (size_buffer(j->mctx, &j->it.source, rrhdr.size)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_read(j, j->it.source.base, rrhdr.size)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (size_buffer(j->mctx, &j->it.target, rrhdr.size)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_name_fromwire(&j->it.name, &j->it.source, 				&j->it.dctx, 0, &j->it.target)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_rdata_fromwire(&j->it.rdata, rdclass, 				 rdtype, &j->it.source, &j->it.dctx, 				 0, &j->it.target)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_sort(&diff[0], rdata_order)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_sort(&diff[1], rdata_order)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (get_name_diff(db[i], ver[i], 0, dbit[i], 					    dns_fixedname_name(&fixname[i]), 					    i == 0 ? 					    DNS_DIFFOP_ADD : 					    DNS_DIFFOP_DEL, 					    &diff[i])); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_diff_subtract(diff, resultdiff)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (itresult[0]);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (itresult[1]);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (diff_namespace(dba, dbvera, dbb, dbverb, DNS_DB_NONSEC3, diff)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (diff_namespace(dba, dbvera, dbb, dbverb, DNS_DB_NSEC3ONLY, diff)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (dns_journal_write_transaction(journal, diff)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_open(mctx, newname, ISC_TRUE, ISC_TRUE, &new)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>while (current_pos.serial != serial) {>>>do { result = (journal_next(j, &current_pos)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_next(j, &best_guess)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, best_guess.offset)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(new, indexend)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_read(j, buf, len)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(new, buf, len)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(new)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(new, 0)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(new, &rawheader, sizeof(rawheader))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(new)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>while (current_pos.serial != new->header.end.serial) {>>>do { result = (journal_next(new, &current_pos)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (index_to_disk(new)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_fsync(new)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_seek(j, sizeof(journal_rawheader_t))); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);>>>do { result = (journal_write(j, j->rawindex, rawbytes)); 							if (result != ISC_R_SUCCESS) goto failure; 		} while (0);"
bind/lib/dns,journal.c,for,20,for (i = 0; i < j->header.index_size; i++) {>>>for (i = 0; i < j->header.index_size; i++) {>>>for (i = 0; i < j->header.index_size; i++) {>>>for (i = 0; i < j->header.index_size; i += 2) {>>>for (i = 0; i < j->header.index_size; i++) {>>>for (t = ISC_LIST_HEAD(diff->tuples); t != ((void *)0);>>>for (t = ISC_LIST_HEAD(diff->tuples); t != ((void *)0);>>>for (result = dns_journal_first_rr(j);>>>for (result = dns_journal_first_rr(j);>>>for (result = dns_rdatasetiter_first(rdsiter);>>>for (result = dns_rdataset_first(&rdataset);>>>for (;;) {>>>for (i = 0; i < 2; i++)>>>for (i = 0; i < 2; i++) {>>>for (;;) {>>>for (i = 0; i < 2; i++) {>>>for (i = 0; i < 2; i++) {>>>for (i = 0; i < j->header.index_size; i++) {>>>for (i = 0; i < copy_length; i += size) {>>>for (i = 0; i < j->header.index_size; i++) {
bind/lib/dns,key.c,for,2,"for (ac = 0; size > 1; size -= 2, p += 2)>>>for (size -= 2, p +=2; size > 1; size -= 2, p += 2)"
bind/lib/dns,keytable.c,while,2,while (knode != NULL) {>>>while (node != NULL) {
bind/lib/dns,keytable.c,for,5,for (k = node->data; k != NULL; k = k->next) {>>>for (knode = data; knode != NULL; knode = knode->next) {>>>for (knode = keynode->next; knode != NULL; knode = knode->next) {>>>for (;;) {>>>for (knode = node->data; knode != NULL; knode = knode->next) {
bind/lib/dns,lookup.c,while,1,} while (want_restart);
bind/lib/dns,master.c,while,76,"} while (value != 0 || width > 0);>>>while (*name != '\0') {>>>while (*name != '\0' && *name++ != '}')>>>while (*cp != '\0') {>>>do { 		result = gettoken(lctx->lex,  ISC_LEXOPT_INITIALWS | ISC_LEXOPT_QSTRING,  			 &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( 			 &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		if (isc_lex_isfile(lctx->lex)) 			(*callbacks->warn)(callbacks, 				""%s: file does not end with newline"", 				source); 	} while (0);>>>do { 		result = commit(callbacks, lctx, &current_list, 				ictx->current, source, ictx->current_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		result = commit(callbacks, lctx, &glue_list, 				ictx->glue, source, ictx->glue_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		rdcount = 0; 		rdlcount = 0; 		isc_buffer_init(&target, target_mem, target_size); 		rdcount_save = rdcount; 		rdlcount_save = rdlcount; 	} while (0);>>>do { 		do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0); 		if (token.type != isc_tokentype_eol) { 			isc_lex_ungettoken(lctx->lex, &token); 			result = DNS_R_EXTRATOKEN; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				continue; 			} else if (result != ISC_R_SUCCESS) 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0); 		if (token.type != isc_tokentype_eol) { 			isc_lex_ungettoken(lctx->lex, &token); 			result = DNS_R_EXTRATOKEN; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				continue; 			} else if (result != ISC_R_SUCCESS) 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = commit(callbacks, lctx, &current_list, 				ictx->current, source, ictx->current_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		result = commit(callbacks, lctx, &glue_list, 				ictx->glue, source, ictx->glue_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		rdcount = 0; 		rdlcount = 0; 		isc_buffer_init(&target, target_mem, target_size); 		rdcount_save = rdcount; 		rdlcount_save = rdlcount; 	} while (0);>>>do { 		result = gettoken(lctx->lex,  ISC_LEXOPT_QSTRING,  &token,  					 ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		if (isc_lex_isfile(lctx->lex)) 			(*callbacks->warn)(callbacks, 				""%s: file does not end with newline"", 				source); 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0); 		if (token.type != isc_tokentype_eol) { 			isc_lex_ungettoken(lctx->lex, &token); 			result = DNS_R_EXTRATOKEN; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				continue; 			} else if (result != ISC_R_SUCCESS) 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  						 ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  						 ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  						 ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  ISC_LEXOPT_QSTRING,  					 &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( 					 &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0); 		if (token.type != isc_tokentype_eol) { 			isc_lex_ungettoken(lctx->lex, &token); 			result = DNS_R_EXTRATOKEN; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				continue; 			} else if (result != ISC_R_SUCCESS) 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_TRUE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0); 		if (token.type != isc_tokentype_eol) { 			isc_lex_ungettoken(lctx->lex, &token); 			result = DNS_R_EXTRATOKEN; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				continue; 			} else if (result != ISC_R_SUCCESS) 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  initialws, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		if (isc_lex_isfile(lctx->lex)) 			(*callbacks->warn)(callbacks, 				""%s: file does not end with newline"", 				source); 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 		result = gettoken(lctx->lex,  0,  &token,  ISC_FALSE, callbacks); 		switch (result) { 		case ISC_R_SUCCESS: 			break; 		case ISC_R_UNEXPECTED: 			goto insist_and_cleanup; 		default: 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 		if (( &token)->type == isc_tokentype_special) { 			result = DNS_R_SYNTAX; 			if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 				do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 				if (result == ISC_R_NOMEMORY) 		(*callbacks->error)(callbacks, ""dns_master_load: %s"", 				    dns_result_totext(result)); 	else 		(*callbacks->error)(callbacks, ""%s: %s:%lu: %s"", 				    ""dns_master_load"", 				    source, line, dns_result_totext(result)); 				read_till_eol = ISC_TRUE; 				goto next_line; 			} else 				goto log_and_cleanup; 		} 	} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>while (this != NULL) {>>>do { 		result = commit(callbacks, lctx, &current_list, 				ictx->current, source, ictx->current_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		result = commit(callbacks, lctx, &glue_list, 				ictx->glue, source, ictx->glue_line); 		if ((( result != ISC_R_SUCCESS) && 		 ( result != ISC_R_IOERROR) && 		 ((lctx)->options & DNS_MASTER_MANYERRORS) != 0)) { 			do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0); 		} else if (result != ISC_R_SUCCESS) 			goto insist_and_cleanup; 		rdcount = 0; 		rdlcount = 0; 		isc_buffer_init(&target, target_mem, target_size); 		rdcount_save = rdcount; 		rdlcount_save = rdlcount; 	} while (0);>>>} while (!done && (lctx->loop_cnt == 0 || loop_cnt++ < lctx->loop_cnt));>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>while ((this = ISC_LIST_HEAD(current_list)) != NULL)>>>while ((this = ISC_LIST_HEAD(glue_list)) != NULL)>>>while ((this = ISC_LIST_HEAD(*current)) != NULL) {>>>while ((this = ISC_LIST_HEAD(save)) != NULL) {>>>while ((this = ISC_LIST_HEAD(*glue)) != NULL) {>>>while ((this = ISC_LIST_HEAD(save)) != NULL) {>>>while (this != NULL) {>>>while ((rdata = ISC_LIST_HEAD(this->rdata)) != NULL) {>>>while ((rdata = ISC_LIST_HEAD(save)) != NULL) {>>>while (this != NULL) {>>>while ((rdata = ISC_LIST_HEAD(this->rdata)) != NULL) {>>>while ((rdata = ISC_LIST_HEAD(save)) != NULL) {>>>while (rdata != NULL) {>>>do { 			if ((lctx)->result == ISC_R_SUCCESS) 				(lctx)->result =  result; 		} while (0);>>>} while (this != NULL);>>>while (this != NULL) {>>>while (rdata != NULL) {"
bind/lib/dns,master.c,for,7,for (i = 0; i < 4; i++) {>>>for (i = start; i <= stop; i += step) {>>>for (new_in_use = 0; new_in_use < 4; new_in_use++)>>>for (new_in_use = 0; new_in_use < 4; new_in_use++)>>>for (i = 0; i < rdcount; i++) {>>>for (j = 0; j < i; j++) {>>>for (i = 0; i < rdcount; i++) {
bind/lib/dns,masterdump.c,while,27,"while (t) {>>>while (t) {>>>do { 	if ((str_totext(""; "", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((dns_name_totext(&name, omit_final_dot, target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((str_totext("" "", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((dns_rdatatype_totext(rds.type, target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((str_totext("" "", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((dns_rdatatype_totext(rds.covers, target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((str_totext("" ...\n"", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((str_totext("" "", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((dns_rdata_tofmttext(&rdata, dns_rootname, 							  0, 0, 0, "" "", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>do { 	if ((str_totext(""\n"", target)) != ISC_R_SUCCESS) 		goto cleanup; 	} while (0);>>>} while (result == ISC_R_SUCCESS);>>>while (result == ISC_R_SUCCESS) {>>>do { 	isc_result_t _r = (dns_name_totext(owner_name, 					       omit_final_dot, 					       target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.ttl_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.class_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.type_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(""\\-"", target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.rdata_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);>>>do { 	isc_result_t _r = (str_totext("";-$NXDOMAIN\n"", target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext("";-$NXRRSET\n"", target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (ncache_summary(rdataset, omit_final_dot, 					      target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (dns_rdata_tofmttext(&rdata, 						   ctx->origin, 						   ctx->style.flags, 						   ctx->style.line_length - 						       ctx->style.rdata_column, 						   ctx->style.split_width, 						   ctx->linebreak, 						   target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (dns_name_totext(owner_name, 				       omit_final_dot, 				       target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.class_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);>>>do { 		 if ((result = indent(&column, ctx->style.type_column, 				      ctx->style.tab_width, target)) 		     != ISC_R_SUCCESS) 			    return (result); 	} while (0);"
bind/lib/dns,masterdump.c,for,1,for (result = dns_rdataset_first(&rds);
bind/lib/dns,message.c,while,26,while (name != NULL) {>>>while (rds != NULL) {>>>while (rdata != NULL) {>>>while (rdatalist != NULL) {>>>while (dynbuf != NULL) {>>>while (msgblock != NULL) {>>>while (msgblock != NULL) {>>>while (msgblock != NULL) {>>>while (dynbuf != NULL) {>>>while (tries < 2) {>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>do {								if (best_effort)						seen_problem = ISC_TRUE;			else {								result = DNS_R_FORMERR;					goto cleanup;					}						} while (0);>>>while (name != NULL) {>>>while (rdataset != NULL) {>>>} while (--pass != 0);>>>} while (result == ISC_R_SUCCESS);>>>while (isc_buffer_remaininglength(&optbuf) != 0) {
bind/lib/dns,message.c,for,15,for (i = 0; i < DNS_SECTION_MAX; i++) {>>>for (i = first_section; i < DNS_SECTION_MAX; i++) {>>>for (i = 0; i < DNS_SECTION_MAX; i++)>>>for (curr = ISC_LIST_TAIL(*section);>>>for (curr = ISC_LIST_TAIL(name->list);>>>for (curr = ISC_LIST_TAIL(name->list);>>>for (;;) {>>>for (count = 0; count < msg->counts[DNS_SECTION_QUESTION]; count++) {>>>for (count = 0; count < msg->counts[sectionid]; count++) {>>>for (i = 0; i < DNS_SECTION_MAX; i++) {>>>for (name = ISC_LIST_HEAD(msg->sections[i]);>>>for (rds = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (i = 0; i < optlen; i++) {>>>for (i = 0; i < optlen; i++) {
bind/lib/dns,name.c,while,32,while (n--) {>>>while (ndata < (name->ndata + name->length)) {>>>while (n--) {>>>while (ndata < (name->ndata + name->length)) {>>>while (n--) {>>>while (label + 1 < name->labels) {>>>while (length > 0) {>>>while (length > 0) {>>>while (l > 0) {>>>while (count > 0) {>>>while (l > 0) {>>>while (count > 0) {>>>while (l > 0) {>>>while (count > 0) {>>>do { 	name->ndata = ((void *)0); 	name->length = 0; 	name->labels = 0; 	name->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>while (nrem > 0 && tlen > 0 && !done) {>>>while (n1 > 0) {>>>while (n2 > 0) {>>>while (labels > 0 && nlen > 0 && trem > 0) {>>>while (count > 0) {>>>while (labels > 0 && nlen > 0 && trem > 0) {>>>while (count > 0) {>>>do { 	name->ndata = ((void *)0); 	name->length = 0; 	name->labels = 0; 	name->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>while (labels > 0 && nlen > 0) {>>>while (count > 0) {>>>while (offset != length) {>>>do { 	name->ndata = ((void *)0); 	name->length = 0; 	name->labels = 0; 	name->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>while (current < source->active && !done) {>>>do { 	name->ndata = ((void *)0); 	name->length = 0; 	name->labels = 0; 	name->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>do { 	name->ndata = ((void *)0); 	name->length = 0; 	name->labels = 0; 	name->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>do { 	target->ndata = ((void *)0); 	target->length = 0; 	target->labels = 0; 	target->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;>>>do { 	target->ndata = ((void *)0); 	target->length = 0; 	target->labels = 0; 	target->attributes &= ~DNS_NAMEATTR_ABSOLUTE; } while (0);;
bind/lib/dns,name.c,for,1,for (i = 0; i < name->labels; i++) {
bind/lib/dns,ncache.c,while,5,while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {
bind/lib/dns,ncache.c,for,2,for (rdataset = ISC_LIST_HEAD(name->list);>>>for (i = 0; i < rcount; i++) {
bind/lib/dns,nsec.c,while,2,"do { 	result = (dns_nsec_buildrdata(db, version, node, target, data, &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdatalist_tordataset(&rdatalist, &rdataset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);"
bind/lib/dns,nsec.c,for,6,for (result = dns_rdatasetiter_first(rdsiter);>>>for (i = 0; i <= max_type; i++) {>>>for (window = 0; window < 256; window++) {>>>for (octet = 31; octet >= 0; octet--)>>>for (i = 0; i < nsecstruct.len; i += len) {>>>for (result = dns_rdataset_first(&rdataset);
bind/lib/dns,nsec3.c,while,75,"do { 	result = (dns_rdata_tostruct(&rdata, &nsec3, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata, nsec3, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_hashname(&fixed, nexthash, &next_length, 				 name, origin, hash, iterations, 				 salt, salt_length)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_db_findnsec3node(db, hashname, ISC_TRUE, &newnode)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_db_createiterator(db, DNS_DB_NSEC3ONLY, &dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_seek(dbit, hashname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_last(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, prev)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, prev, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(&rdata, rdataset.rdclass, 					   dns_rdatatype_nsec3, &nsec3, 					   &buffer)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, prev, 					   rdataset.ttl, &rdata, &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (pass < 2);>>>do { 	result = (dns_db_findnode(db, name, ISC_FALSE, &node)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_buildrdata(db, version, node, hash, flags, iterations, 				   salt, salt_length, nexthash, next_length, 				   nsec3buf, &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, hashname, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, 				   hashname, nsecttl, &rdata, &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (name_exists(db, version, &empty, &exists)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_hashname(&fixed, nexthash, &next_length, 					 &empty, origin, hash, iterations, 					 salt, salt_length)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_db_findnsec3node(db, hashname, ISC_TRUE, &newnode)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_seek(dbit, hashname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_last(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, prev)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, prev, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(&rdata, rdataset.rdclass, 						   dns_rdatatype_nsec3, &nsec3, 						   &buffer)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, 						   prev, rdataset.ttl, &rdata, 						   &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (pass < 2);>>>do { 	result = (dns_nsec3_buildrdata(db, version, NULL, hash, flags, 					   iterations, salt, salt_length, 					   nexthash, next_length, nsec3buf, 					   &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, hashname, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, 					   hashname, nsecttl, &rdata, &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (1);>>>do { 	result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_addnsec3(db, version, name, &nsec3param, 					 nsecttl, unsecure, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_addnsec3(db, version, name, &nsec3param, 					 nsecttl, unsecure, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata2, &nsec3param, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_addnsec3(db, version, name, &nsec3param, 					 nsecttl, unsecure, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_hashname(&fixed, nexthash, &next_length, 				 name, origin, hash, iterations, 				 salt, salt_length)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_db_createiterator(db, DNS_DB_NSEC3ONLY, &dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_last(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, prev)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, prev, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(&rdata, rdataset.rdclass, 					   dns_rdatatype_nsec3, &nsec3, 					   &buffer)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, prev, 					   rdataset.ttl, &rdata, &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (pass < 2);>>>do { 	result = (delete(db, version, hashname, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (deleteit(db, version, &empty, &yesno)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_hashname(&fixed, nexthash, &next_length, 					 &empty, origin, hash, iterations, 					 salt, salt_length)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_last(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_current(dbit, &node, prev)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dbiterator_pause(dbit)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (delete(db, version, prev, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(&rdata, rdataset.rdclass, 						   dns_rdatatype_nsec3, &nsec3, 						   &buffer)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, 						   prev, rdataset.ttl, &rdata, 						   &tuple)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (do_one_tuple(&tuple, db, version, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (pass < 2);>>>do { 	result = (delete(db, version, hashname, nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>} while (1);>>>do { 	result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_delnsec3(db, version, name, &nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata2, &nsec3param, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_nsec3_delnsec3(db, version, name, &nsec3param, diff)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_fromdns(dns_db_origin(db), rdataset.rdclass, 				      &buffer, mctx, &key)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);"
bind/lib/dns,nsec3.c,for,16,for (result = dns_rdatasetiter_first(rdsiter);>>>for (i = 0; i <= max_type; i++) {>>>for (window = 0; window < 256; window++) {>>>for (octet = 31; octet >= 0; octet--)>>>for (i = 0; i < nsec3.len; i += len) {>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&prdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);
bind/lib/dns,order.c,while,1,while ((ent = ISC_LIST_HEAD(order->ents)) != NULL) {
bind/lib/dns,order.c,for,1,for (ent = ISC_LIST_HEAD(order->ents);
bind/lib/dns,peer.c,while,2,while (server != NULL) {>>>while (server != NULL) {
bind/lib/dns,peer.c,for,1,for (p = ISC_LIST_HEAD(peers->elements);
bind/lib/dns,portlist.c,for,1,for (;;) {
bind/lib/dns,private.c,while,5,"do {								 result = (dns_db_getoriginnode(db, &node));						 if (result != ISC_R_SUCCESS)					goto failure;				 } while (0);>>>do {								 result = (ISC_R_FAILURE);						 if (result != ISC_R_SUCCESS)					goto failure;				 } while (0);>>>do {								 result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL));						 if (result != ISC_R_SUCCESS)					goto failure;				 } while (0);>>>do {								 result = (dns_rdata_fromstruct(&rdata, dns_rdataclass_in, 					   dns_rdatatype_nsec3param, 					   &nsec3param, &b));						 if (result != ISC_R_SUCCESS)					goto failure;				 } while (0);>>>do {								 result = (dns_rdata_totext(&rdata, NULL, buf));						 if (result != ISC_R_SUCCESS)					goto failure;				 } while (0);"
bind/lib/dns,private.c,for,5,for (result = dns_rdataset_first(privateset);>>>for (result = dns_rdataset_first(&privateset);>>>for (result = dns_rdataset_first(&privateset);>>>for (result = dns_rdataset_first(&nsec3paramset);>>>for (result = dns_rdataset_first(&privateset);
bind/lib/dns,rbt.c,while,34,do { 	( &nodename)->length = ((chain->end)->namelen); 	( &nodename)->labels = ((chain->end)->offsetlen); 	( &nodename)->ndata = ((unsigned char *)((chain->end) + 1)); 	( &nodename)->offsets = (((unsigned char *)((chain->end) + 1)) + ((chain->end)->oldnamelen) + 1); 	( &nodename)->attributes = ((chain->end)->attributes); 	( &nodename)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>do { 	( &nodename)->length = ((chain->levels[i])->namelen); 	( &nodename)->labels = ((chain->levels[i])->offsetlen); 	( &nodename)->ndata = ((unsigned char *)((chain->levels[i]) + 1)); 	( &nodename)->offsets = (((unsigned char *)((chain->levels[i]) + 1)) + ((chain->levels[i])->oldnamelen) + 1); 	( &nodename)->attributes = ((chain->levels[i])->attributes); 	( &nodename)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (((node)->right) != NULL)>>>} while (1);>>>do { 	( &current_name)->length = ((current)->namelen); 	( &current_name)->labels = ((current)->offsetlen); 	( &current_name)->ndata = ((unsigned char *)((current) + 1)); 	( &current_name)->offsets = (((unsigned char *)((current) + 1)) + ((current)->oldnamelen) + 1); 	( &current_name)->attributes = ((current)->attributes); 	( &current_name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>} while (child != NULL);>>>while (current != NULL) {>>>do { 	( &current_name)->length = ((current)->namelen); 	( &current_name)->labels = ((current)->offsetlen); 	( &current_name)->ndata = ((unsigned char *)((current) + 1)); 	( &current_name)->offsets = (((unsigned char *)((current) + 1)) + ((current)->oldnamelen) + 1); 	( &current_name)->attributes = ((current)->attributes); 	( &current_name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (chain->levels[chain->level_matches] != *node) {>>>while (current != NULL) {>>>do { 	( &current_name)->length = ((current)->namelen); 	( &current_name)->labels = ((current)->offsetlen); 	( &current_name)->ndata = ((unsigned char *)((current) + 1)); 	( &current_name)->offsets = (((unsigned char *)((current) + 1)) + ((current)->oldnamelen) + 1); 	( &current_name)->attributes = ((current)->attributes); 	( &current_name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>do { 	( name)->length = ((node)->namelen); 	( name)->labels = ((node)->offsetlen); 	( name)->ndata = ((unsigned char *)((node) + 1)); 	( name)->offsets = (((unsigned char *)((node) + 1)) + ((node)->oldnamelen) + 1); 	( name)->attributes = ((node)->attributes); 	( name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>do { 	( &current)->length = ((node)->namelen); 	( &current)->labels = ((node)->offsetlen); 	( &current)->ndata = ((unsigned char *)((node) + 1)); 	( &current)->offsets = (((unsigned char *)((node) + 1)) + ((node)->oldnamelen) + 1); 	( &current)->attributes = ((node)->attributes); 	( &current)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>} while (! dns_name_isabsolute(name));>>>do { 	( &add_name)->length = ((node)->namelen); 	( &add_name)->labels = ((node)->offsetlen); 	( &add_name)->ndata = ((unsigned char *)((node) + 1)); 	( &add_name)->offsets = (((unsigned char *)((node) + 1)) + ((node)->oldnamelen) + 1); 	( &add_name)->attributes = ((node)->attributes); 	( &add_name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>do { 	( &current_name)->length = ((current)->namelen); 	( &current_name)->labels = ((current)->offsetlen); 	( &current_name)->ndata = ((unsigned char *)((current) + 1)); 	( &current_name)->offsets = (((unsigned char *)((current) + 1)) + ((current)->oldnamelen) + 1); 	( &current_name)->attributes = ((current)->attributes); 	( &current_name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (node != root && ((((node)->parent)) != NULL && (((node)->parent))->color == 0)) {>>>while (((successor)->left) != NULL)>>>while (child != *rootp && ((child) == NULL || (child)->color == 1)) {>>>do { 	( name)->length = ((chain->end)->namelen); 	( name)->labels = ((chain->end)->offsetlen); 	( name)->ndata = ((unsigned char *)((chain->end) + 1)); 	( name)->offsets = (((unsigned char *)((chain->end) + 1)) + ((chain->end)->oldnamelen) + 1); 	( name)->attributes = ((chain->end)->attributes); 	( name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (((current)->right) != NULL)>>>while (! ISC_TF((current)->is_root == 1)) {>>>while (((predecessor)->right) != NULL)>>>} while (((predecessor)->down) != NULL);>>>while (((current)->left) != NULL)>>>do { 	( name)->length = ((chain->end)->namelen); 	( name)->labels = ((chain->end)->offsetlen); 	( name)->ndata = ((unsigned char *)((chain->end) + 1)); 	( name)->offsets = (((unsigned char *)((chain->end) + 1)) + ((chain->end)->oldnamelen) + 1); 	( name)->attributes = ((chain->end)->attributes); 	( name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (! ISC_TF((current)->is_root == 1)) {>>>while (((current)->left) != NULL)>>>do { 	( name)->length = ((chain->end)->namelen); 	( name)->labels = ((chain->end)->offsetlen); 	( name)->ndata = ((unsigned char *)((chain->end) + 1)); 	( name)->offsets = (((unsigned char *)((chain->end) + 1)) + ((chain->end)->oldnamelen) + 1); 	( name)->attributes = ((chain->end)->attributes); 	( name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);>>>while (((current)->left) != NULL)>>>while (! ISC_TF((current)->is_root == 1)) {>>>} while (successor == NULL);>>>while (((current)->left) != NULL)>>>do { 	( name)->length = ((chain->end)->namelen); 	( name)->labels = ((chain->end)->offsetlen); 	( name)->ndata = ((unsigned char *)((chain->end) + 1)); 	( name)->offsets = (((unsigned char *)((chain->end) + 1)) + ((chain->end)->oldnamelen) + 1); 	( name)->attributes = ((chain->end)->attributes); 	( name)->attributes |= DNS_NAMEATTR_READONLY; } while (0);
bind/lib/dns,rbt.c,for,3,for (root = node; ! ISC_TF((root)->is_root == 1); root = ((root)->parent))>>>for (i = (int)chain->level_count - 1; i >= 0; i--) {>>>for (i = 0; i < depth; i++)
bind/lib/dns,rbtdb.c,while,30,"while (node != NULL) {>>>} while (dcurrent != NULL);>>>while (node != NULL && count > 0) {>>>} while (node != NULL);>>>while (i < n) {>>>} while (header != NULL);>>>while (count > 0) {>>>while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN) {>>>} while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN);>>>while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN) {>>>} while (!dns_name_equal(&rname, &tname));>>>while (result == ISC_R_SUCCESS && j != 0) {>>>} while (!done);>>>while (count-- > 0) {>>>} while (header != NULL);>>>} while (empty_node && result == ISC_R_SUCCESS);>>>} while (header != NULL);>>>while (result == ISC_R_SUCCESS && i > 0) {>>>} while (!done);>>>} while (empty_node && result == ISC_R_SUCCESS);>>>} while (current != NULL);>>>} while (header != NULL);>>>} while (header != NULL);>>>} while (header != NULL);>>>while (header != NULL && (((header)->attributes & 0x0004) != 0))>>>while (header != NULL && (((header)->attributes & 0x0004) != 0))>>>while (current != NULL) {>>>while (i-- > 0) {>>>} while (header != NULL);>>>} while (header != NULL);"
bind/lib/dns,rbtdb.c,for,38,for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (;;) {>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < count; i++)>>>for (header = node->data; header != NULL; header = header->next) {>>>for (d = top->down; d != NULL; d = down_next) {>>>for (current = node->data; current != NULL; current = top_next) {>>>for (current = node->data; current != NULL; current = top_next) {>>>for (changed = HEAD(version->changed_list);>>>for (locknum = 0; locknum < rbtdb->node_lock_count; locknum++) {>>>for (header = HEAD(resigned_list);>>>for (changed = HEAD(cleanup_list);>>>for (header = node->data; header != NULL; header = header_next) {>>>for (;;) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = rbtnode->data; header != NULL; header = header->next)>>>for (header = rbtnode->data; header != NULL; header = header_next) {>>>for (header = rbtnode->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++) {>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)(rbtdb->node_lock_count); i++) {>>>for (i = 0 ; i < (int)rbtdb->node_lock_count ; i++)>>>for (header = rbtnode->data; header != NULL; header = top_next) {>>>for (header = header->next; header != NULL; header = top_next) {>>>for (i = 0; i < rbtdbiter->delete; i++) {>>>for (locknum = (locknum_start + 1) % rbtdb->node_lock_count;>>>for (header = ISC_LIST_TAIL(rbtdb->rdatasets[locknum]);
bind/lib/dns,rbtdb64.c,while,30,"while (node != NULL) {>>>} while (dcurrent != NULL);>>>while (node != NULL && count > 0) {>>>} while (node != NULL);>>>while (i < n) {>>>} while (header != NULL);>>>while (count > 0) {>>>while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN) {>>>} while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN);>>>while (result == ISC_R_SUCCESS || result == DNS_R_NEWORIGIN) {>>>} while (!dns_name_equal(&rname, &tname));>>>while (result == ISC_R_SUCCESS && j != 0) {>>>} while (!done);>>>while (count-- > 0) {>>>} while (header != NULL);>>>} while (empty_node && result == ISC_R_SUCCESS);>>>} while (header != NULL);>>>while (result == ISC_R_SUCCESS && i > 0) {>>>} while (!done);>>>} while (empty_node && result == ISC_R_SUCCESS);>>>} while (current != NULL);>>>} while (header != NULL);>>>} while (header != NULL);>>>} while (header != NULL);>>>while (header != NULL && (((header)->attributes & 0x0004) != 0))>>>while (header != NULL && (((header)->attributes & 0x0004) != 0))>>>while (current != NULL) {>>>while (i-- > 0) {>>>} while (header != NULL);>>>} while (header != NULL);"
bind/lib/dns,rbtdb64.c,for,38,for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (;;) {>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++)>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < count; i++)>>>for (header = node->data; header != NULL; header = header->next) {>>>for (d = top->down; d != NULL; d = down_next) {>>>for (current = node->data; current != NULL; current = top_next) {>>>for (current = node->data; current != NULL; current = top_next) {>>>for (changed = HEAD(version->changed_list);>>>for (locknum = 0; locknum < rbtdb->node_lock_count; locknum++) {>>>for (header = HEAD(resigned_list);>>>for (changed = HEAD(cleanup_list);>>>for (header = node->data; header != NULL; header = header_next) {>>>for (;;) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (header = rbtnode->data; header != NULL; header = header->next)>>>for (header = rbtnode->data; header != NULL; header = header_next) {>>>for (header = rbtnode->data; header != NULL; header = header_next) {>>>for (header = node->data; header != NULL; header = header_next) {>>>for (i = 0; i < rbtdb->node_lock_count; i++) {>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++) {>>>for (i = 0; i < (int)rbtdb->node_lock_count; i++)>>>for (i = 0; i < (int)(rbtdb->node_lock_count); i++) {>>>for (i = 0 ; i < (int)rbtdb->node_lock_count ; i++)>>>for (header = rbtnode->data; header != NULL; header = top_next) {>>>for (header = header->next; header != NULL; header = top_next) {>>>for (i = 0; i < rbtdbiter->delete; i++) {>>>for (locknum = (locknum_start + 1) % rbtdb->node_lock_count;>>>for (header = ISC_LIST_TAIL(rbtdb->rdatasets[locknum]);
bind/lib/dns,rcode.c,while,8,"while (table[i].name != NULL) {>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, rcodes, 0xffff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, tsigrcodes, 0xffff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, certs, 0xffff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, secalgs, 0xff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, secprotos, 0xff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (dns_mnemonic_fromtext(&value, source, hashalgs, 0xff)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>while (text < end) {"
bind/lib/dns,rcode.c,for,2,for (i = 0; table[i].name != NULL; i++) {>>>for (p = keyflags; p->name != NULL; p++) {
bind/lib/dns,tsig_250.c,while,1,} while (sigtime != 0);
bind/lib/dns,gpos_27.c,for,3,for (i = 0; i < 3; i++) {>>>for (i = 0; i < 3; i++) {>>>for (i = 0; i < 3; i++)
bind/lib/dns,hinfo_13.c,for,1,for (i = 0; i < 2; i++) {
bind/lib/dns,hip_55.c,while,4,} while (1);>>>while (region.length > 0) {>>>while (isc_buffer_activelength(source) > 0) {>>>while (r1.length != 0 && r2.length != 0) {
bind/lib/dns,hip_55.c,for,1,for (result = dns_rdata_hip_first(&myhip);
bind/lib/dns,loc_29.c,while,2,while (*e != 0) {>>>while (*e != 0) {
bind/lib/dns,loc_29.c,for,15,for (i = 0; i < 3; i++) {>>>for (; i < 3; i++)>>>for (i = 0; i < 3; i++) {>>>for (; i < 3; i++)>>>for (i = 0; i < 2; i++) {>>>for (; i < 2; i++)>>>for (i = 0; i < 2; i++) {>>>for (; i < 2; i++)>>>for (exp = 0; exp < 7; exp++)>>>for (i = 0; i < 2; i++) {>>>for (; i < 2; i++)>>>for (exp = 0; exp < 7; exp++)>>>for (i = 0; i < 2; i++) {>>>for (; i < 2; i++)>>>for (exp = 0; exp < 7; exp++)
bind/lib/dns,minfo_14.c,for,1,for (i = 0; i < 2; i++) {
bind/lib/dns,naptr_35.c,while,1,while (len-- > 0) {
bind/lib/dns,naptr_35.c,for,1,"for (i = 0; i < flagslen; i++, cp++) {"
bind/lib/dns,nsec3_50.c,while,1,} while (1);
bind/lib/dns,nsec3_50.c,for,7,for (window = 0; window < 256 ; window++) {>>>for (octet = 31; octet >= 0; octet--)>>>for (i = 0; i < sr.length; i += len) {>>>for (j = 0; j < len; j++) {>>>for (k = 0; k < 8; k++) {>>>for (i = 0; i < sr.length; i += len) {>>>for (i = 0; i < nsec3->len ; i += len) {
bind/lib/dns,nsec_47.c,while,1,} while (1);
bind/lib/dns,nsec_47.c,for,7,for (window = 0; window < 256 ; window++) {>>>for (octet = 31; octet >= 0; octet--)>>>for (i = 0; i < sr.length; i += len) {>>>for (j = 0; j < len; j++) {>>>for (k = 0; k < 8; k++) {>>>for (i = 0; i < sr.length; i += len) {>>>for (i = 0; i < nsec->len ; i += len) {
bind/lib/dns,nxt_30.c,while,1,} while (1);
bind/lib/dns,nxt_30.c,for,2,for (i = 0; i < sr.length; i++) {>>>for (j = 0; j < 8; j++)
bind/lib/dns,opt_41.c,while,3,while (r.length > 0) {>>>while (sregion.length != 0) {>>>while (region.length >= 4) {
bind/lib/dns,rp_17.c,for,1,for (i = 0; i < 2; i++) {
bind/lib/dns,soa_6.c,for,3,for (i = 0; i < 2; i++) {>>>for (i = 0; i < 4; i++) {>>>for (i = 0; i < 5; i++) {
bind/lib/dns,spf_99.c,while,3,while (region.length > 0) {>>>} while (!buffer_empty(source));>>>while (region.length > 0) {
bind/lib/dns,spf_99.c,for,1,for (;;) {
bind/lib/dns,txt_16.c,while,3,while (region.length > 0) {>>>} while (!buffer_empty(source));>>>while (region.length > 0) {
bind/lib/dns,txt_16.c,for,1,for (;;) {
bind/lib/dns,uri_256.c,while,1,while (region.length > 0) {
bind/lib/dns,x25_19.c,for,2,for (i = 0; i < token.value.as_textregion.length; i++)>>>for (i = 0; i < x25->x25_len; i++)
bind/lib/dns,apl_42.c,while,3,} while (1);>>>while (sr.length > 0) {>>>while (sr.length > 0) {
bind/lib/dns,apl_42.c,for,2,for (len = 4; len > 0; len--)>>>for (len = 16; len > 0; len--)
bind/lib/dns,nsap_22.c,while,2,while (sr->length > 0) {>>>while (region.length != 0) {
bind/lib/dns,wks_11.c,while,1,} while (1);
bind/lib/dns,wks_11.c,for,3,for (i = strlen(service) - 1; i >= 0; i--)>>>for (i = 0; i < sr.length; i++) {>>>for (j = 0; j < 8; j++)
bind/lib/dns,rdata.c,while,26,"} while (1);>>>while (n--) {>>>while (n-- != 0) {>>>while (n--) {>>>} while (source->length != 0);>>>while (n != 0) {>>>} while (n != 0);>>>} while (sregion.length != 0);>>>do { 		isc_result_t _r = (putbyte(0, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte(0, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte(0, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte(0, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte((state->word >> 24) & 0xff, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte((state->word >> 16) & 0xff, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte((state->word >> 8) & 0xff, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (putbyte(state->word & 0xff, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, isc_tokentype_string, 				      ISC_FALSE)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>while (token.value.as_textregion.length != 0) {>>>do { 		isc_result_t _r = (byte_atob(c, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, isc_tokentype_number, 				      ISC_FALSE)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, isc_tokentype_string, 				      ISC_FALSE)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, isc_tokentype_string, 				      ISC_FALSE)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, isc_tokentype_string, 				      ISC_FALSE)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>do { 		isc_result_t _r = (byte_btoa(*inbuf, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);>>>while (state->bcount != 0)>>>do { 		isc_result_t _r = (byte_btoa(0, target, state)); 		if (_r != ISC_R_SUCCESS) 			return (_r); 	} while (0);"
bind/lib/dns,rdata.c,for,1,"for (inc = 0; inc < inbuflen; inbuf++, inc++)"
bind/lib/dns,rdatalist.c,for,9,for (rdata = ISC_LIST_HEAD(rdatalist->rdata);>>>for (rdset = ISC_LIST_HEAD(name->list);>>>for (rdset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(noqname->list);>>>for (rdataset = ISC_LIST_HEAD(noqname->list);>>>for (rdset = ISC_LIST_HEAD(name->list);>>>for (rdset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(closest->list);>>>for (rdataset = ISC_LIST_HEAD(closest->list);
bind/lib/dns,rdataset.c,while,3,} while (result == ISC_R_SUCCESS);>>>} while (result == ISC_R_SUCCESS);>>>} while (result == ISC_R_SUCCESS);
bind/lib/dns,rdataset.c,for,3,for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++) {
bind/lib/dns,rdataslab.c,while,5,while (count > 0) {>>>} while (ncount > 0);>>>while (oadded < ocount || nadded < ncount) {>>>while (count1 > 0) {>>>while (count1-- > 0) {
bind/lib/dns,rdataslab.c,for,9,for (i = 0; i < nalloc && result == ISC_R_SUCCESS; i++) {>>>for (i = 1; i < nalloc; i++) {>>>for (i = 0; i < nalloc; i++) {>>>for (i = 0; i < count; i++) {>>>for (count = 0; count < ocount; count++) {>>>for (i = 0; i < mcount; i++) {>>>for (count = 0; count < scount; count++) {>>>for (i = 0; i < mcount; i++) {>>>for (count = 0; count < scount; count++) {
bind/lib/dns,request.c,while,1,while (--i >= 0)
bind/lib/dns,request.c,for,4,for (i = 0; i < 7; i++) {>>>for (request = ISC_LIST_HEAD(requestmgr->requests);>>>for (event = ISC_LIST_HEAD(requestmgr->whenshutdown);>>>for (i = 0; i < 7; i++)
bind/lib/dns,resolver.c,while,22,while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (!ISC_LIST_EMPTY(find->list)) {>>>while (curr != NULL) {>>>while (!ISC_LIST_EMPTY(*findlist)) {>>>while (curr != NULL) {>>>while (sa != NULL) {>>>while (cur != NULL && cur->srtt < ai->srtt)>>>while (cur != NULL && cur->srtt < ai->srtt)>>>} while (find != start);>>>} while (find != start);>>>while (validator != NULL) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (!done && result == ISC_R_SUCCESS) {>>>while (!done && result == ISC_R_SUCCESS) {>>>} while (result == ISC_R_NOSPACE);>>>while ((a = ISC_LIST_HEAD(res->alternates)) != NULL) {
bind/lib/dns,resolver.c,for,78,"for (result = dns_rdataset_first(rdataset);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (addrinfo = ISC_LIST_HEAD(fctx->forwaddrs);>>>for (find = ISC_LIST_HEAD(fctx->finds);>>>for (addrinfo = ISC_LIST_HEAD(find->list);>>>for (addrinfo = ISC_LIST_HEAD(fctx->altaddrs);>>>for (find = ISC_LIST_HEAD(fctx->altfinds);>>>for (addrinfo = ISC_LIST_HEAD(find->list);>>>for (query = ISC_LIST_HEAD(fctx->queries);>>>for (find = ISC_LIST_HEAD(fctx->finds);>>>for (find = ISC_LIST_HEAD(fctx->altfinds);>>>for (addr = ISC_LIST_HEAD(fctx->forwaddrs);>>>for (addr = ISC_LIST_HEAD(fctx->altaddrs);>>>for (event = ISC_LIST_HEAD(fctx->events);>>>for (sa = ISC_LIST_HEAD(fctx->bad_edns);>>>for (sa = ISC_LIST_HEAD(fctx->edns);>>>for (sa = ISC_LIST_HEAD(fctx->edns512);>>>for (sa = ISC_LIST_HEAD(fctx->bad);>>>for (curr = ISC_LIST_HEAD(fctx->finds);>>>for (addrinfo = ISC_LIST_HEAD(curr->list);>>>for (addrinfo = ISC_LIST_HEAD(fctx->forwaddrs);>>>for (curr = ISC_LIST_HEAD(fctx->altfinds);>>>for (addrinfo = ISC_LIST_HEAD(curr->list);>>>for (addrinfo = ISC_LIST_HEAD(fctx->altaddrs);>>>for (curr = ISC_LIST_HEAD(*findlist);>>>for (ai = ISC_LIST_HEAD(find->list);>>>for (result = dns_rdataset_first(&fctx->nameservers);>>>for (a = ISC_LIST_HEAD(fctx->res->alternates);>>>for (addrinfo = ISC_LIST_HEAD(fctx->forwaddrs);>>>for (addrinfo = ISC_LIST_HEAD(find->list);>>>for (addrinfo = ISC_LIST_HEAD(find->list);>>>for (addrinfo = ISC_LIST_HEAD(fctx->altaddrs);>>>for (sa = ISC_LIST_HEAD(fctx->bad);>>>for (sa = ISC_LIST_HEAD(fctx->edns);>>>for (sa = ISC_LIST_HEAD(fctx->edns512);>>>for (sa = ISC_LIST_HEAD(fctx->bad_edns);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (event = ISC_LIST_NEXT(hevent, ev_link);>>>for (validator = ISC_LIST_HEAD(fctx->validators);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (sigrdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (sigrdataset = ISC_LIST_HEAD(name->list);>>>for (trdataset = ISC_LIST_HEAD(tname->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_message_firstname(fctx->rmessage, section);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_message_firstname(message, section);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (i = 0; i < nsid_len; i++) {>>>for (result = dns_message_firstname(message, DNS_SECTION_AUTHORITY);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (i = 0; i < res->badhash; i++)>>>for (i = 0; i < res->nbuckets; i++) {>>>for (event = ISC_LIST_HEAD(res->whenshutdown);>>>for (i = 0; i < ntasks; i++) {>>>for (i = 0; i < buckets_created; i++) {>>>for (i = 0; i < res->nbuckets; i++) {>>>for (fctx = ISC_LIST_HEAD(res->buckets[i].fctxs);>>>for (fctx = ISC_LIST_HEAD(res->buckets[bucketnum].fctxs);>>>for (fevent = ISC_LIST_HEAD(fctx->events);>>>for (event = ISC_LIST_HEAD(fctx->events);>>>for (event = ISC_LIST_HEAD(fctx->events);>>>for (bad = resolver->badcache[i]; bad != NULL; bad = next) {>>>for (i = 0; i < resolver->badhash; i++) {>>>for (bad = resolver->badcache[i]; bad != NULL; bad = next) {>>>for (bad = resolver->badcache[i]; bad != NULL; bad = next) {>>>for (bad = resolver->badcache[i]; bad != NULL; bad = next) {>>>for (i = 0; i < resolver->badhash; i++) {>>>for (bad = resolver->badcache[i]; bad != NULL; bad = next) {"
bind/lib/dns,rootns.c,while,12,while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {
bind/lib/dns,rpz.c,while,9,while (cur != NULL) {>>>while (!ISC_LIST_EMPTY(view->rpz_zones)) {>>>while (i < words) {>>>while (i < (128/((int)sizeof(dns_rpz_cidr_word_t)*8)))>>>while (i < (128/((int)sizeof(dns_rpz_cidr_word_t)*8)) * 2) {>>>while (i < (128/((int)sizeof(dns_rpz_cidr_word_t)*8)) * 2 && w[i] == 0)>>>} while (ip_labels + i <= 8);>>>while (bits < ((int)sizeof(dns_rpz_cidr_key_t)*8)) {>>>} while (tgt != NULL);
bind/lib/dns,rpz.c,for,6,for (;;) {>>>for (i = 0; i < (128/((int)sizeof(dns_rpz_cidr_word_t)*8)); i++) {>>>for (i = 0; i < 32; i += 8) {>>>for (;;) {>>>for (parent = tgt; parent != NULL; parent = parent->parent) {>>>for (i = 0; i < 4; i++) {
bind/lib/dns,rriterator.c,while,2,while (it->result == ISC_R_SUCCESS) {>>>while (it->result == ISC_R_NOMORE) {
bind/lib/dns,sdb.c,while,18,while (rdatalist != ((void *)0)) {>>>} while (result == ISC_R_NOSPACE);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					LOCK(&sdb->implementation->driverlock);			} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					UNLOCK(&sdb->implementation->driverlock);		} while (0);>>>while (!ISC_LIST_EMPTY(node->lists)) {>>>while (!ISC_LIST_EMPTY(list->rdata)) {>>>while (!ISC_LIST_EMPTY(node->buffers)) {>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					LOCK(&sdb->implementation->driverlock);			} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					UNLOCK(&sdb->implementation->driverlock);		} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					LOCK(&sdb->implementation->driverlock);			} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					UNLOCK(&sdb->implementation->driverlock);		} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					LOCK(&sdb->implementation->driverlock);			} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					UNLOCK(&sdb->implementation->driverlock);		} while (0);>>>while (list != ((void *)0)) {>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					LOCK(&sdb->implementation->driverlock);			} while (0);>>>do {										unsigned int flags = sdb->implementation->flags;			if ((flags & DNS_SDBFLAG_THREADSAFE) == 0)					UNLOCK(&sdb->implementation->driverlock);		} while (0);>>>while (!ISC_LIST_EMPTY(sdbiter->nodelist)) {>>>while (sdbiter->current != ((void *)0)) {
bind/lib/dns,sdb.c,for,2,for (size = 1024; size < (64 * 1024); size *= 2)>>>for (; i <= nlabels; i++) {
bind/lib/dns,sdlz.c,while,30,while (!ISC_LIST_EMPTY(node->lists)) {>>>while (!ISC_LIST_EMPTY(list->rdata)) {>>>while (!ISC_LIST_EMPTY(node->buffers)) {>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>while (list != ((void *)0)) {>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>do { 		unsigned int flags = sdlz->dlzimp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&sdlz->dlzimp->driverlock); 	} while (0);>>>while (!ISC_LIST_EMPTY(sdlziter->nodelist)) {>>>while (sdlziter->current != ((void *)0)) {>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			LOCK(&imp->driverlock); 	} while (0);>>>do { 		unsigned int flags = imp->flags; 		if ((flags & DNS_SDLZFLAG_THREADSAFE) == 0) 			UNLOCK(&imp->driverlock); 	} while (0);>>>while (rdatalist != ((void *)0)) {>>>} while (result == ISC_R_NOSPACE);
bind/lib/dns,sdlz.c,for,2,for (i = 0; i < len; i++) {>>>for (i = olabels; i <= nlabels; i++) {
bind/lib/dns,spnego_asn1.c,while,2,while (ret < origlen) {>>>while ((data)->len) {
bind/lib/dns,spnego_asn1.c,for,1,for (i = (data)->len - 1; i >= 0; --i) {
bind/lib/dns,ssu.c,while,1,while (!ISC_LIST_EMPTY(table->rules)) {
bind/lib/dns,ssu.c,for,2,for (rule = ISC_LIST_HEAD(table->rules);>>>for (i = 0; i < rule->ntypes; i++) {
bind/lib/dns,stats.c,for,1,for (i = 0; i < DNS_STATS_NCOUNTERS; i++)
bind/lib/dns,dbdiff_test.c,for,2,for (tuple = ISC_LIST_HEAD(diff.tuples); tuple != ((void *)0);>>>for (tuple = ISC_LIST_HEAD(diff.tuples); tuple != ((void *)0);
bind/lib/dns,dbiterator_test.c,while,1,while (result == ISC_R_SUCCESS) {
bind/lib/dns,dbiterator_test.c,for,2,for (result = dns_dbiterator_first(iter);>>>for (result = dns_dbiterator_last(iter);
bind/lib/dns,dnstest.c,while,18,"do { 		result = (isc_taskmgr_create(mctx, ncpus, 0, &taskmgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_timermgr_create(mctx, &timermgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_socketmgr_create(mctx, &socketmgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_task_create(taskmgr, 0, &maintask)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_app_start()); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_mem_create(0, 0, &mctx)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_entropy_create(mctx, &ectx)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_hash_create(mctx, ectx, DNS_NAME_MAXWIRE)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (dst_lib_init(mctx, ectx, ISC_ENTROPY_BLOCKING)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_create(mctx, &lctx, &logconfig)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_createchannel(logconfig, ""stderr"", 					    ISC_LOG_TOFILEDESC, 					    ISC_LOG_DYNAMIC, 					    &destination, 0)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_usechannel(logconfig, ""stderr"", ((void *)0), ((void *)0))); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (create_managers()); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (ISC_R_FAILURE); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (dns_view_create(mctx, dns_rdataclass_in, ""view"", &view)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (dns_zone_create(&zone, mctx)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (dns_name_fromtext(origin, &buffer, dns_rootname, 0, ((void *)0))); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (dns_zone_setorigin(zone, origin)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);"
bind/lib/dns,private_test.c,while,1,while (*sp == '\0' && slen > 0) {
bind/lib/dns,private_test.c,for,2,for (i = 0; i < ncases; i++) {>>>for (i = 0; i < ncases; i++) {
bind/lib/dns,zt_test.c,while,2,while (dns__zone_loadpending(zone) && i++ < 5000)>>>while (!done && i++ < 5000)
bind/lib/dns,time.c,while,12,while (t < 0) {>>>while ((secs = ((((((tm.tm_year + 1900) % 4) == 0 && ((tm.tm_year + 1900) % 100) != 0) || ((tm.tm_year + 1900) % 400) == 0) ? 366 : 365 ) * 86400)) <= t) {>>>while ((secs = ((days[tm.tm_mon] + ((tm.tm_mon == 1 && (((( tm.tm_year + 1900) % 4) == 0 && (( tm.tm_year + 1900) % 100) != 0) || (( tm.tm_year + 1900) % 400) == 0)) ? 1 : 0 )) * 86400)) <= t) {>>>while (86400 <= t) {>>>while (3600 <= t) {>>>while (60 <= t) {>>>do { 		if ( year < (0) ||  year > ( 9999)) 			return (ISC_R_RANGE); 	} while (0);>>>do { 		if ( month < (1) ||  month > ( 12)) 			return (ISC_R_RANGE); 	} while (0);>>>do { 		if ( day < (1) ||  day > ( days[month - 1] + 		 ((month == 2 && ((((year) % 4) == 0 && ((year) % 100) != 0) || ((year) % 400) == 0)) ? 1 : 0))) 			return (ISC_R_RANGE); 	} while (0);>>>do { 		if ( hour < (0) ||  hour > ( 23)) 			return (ISC_R_RANGE); 	} while (0);>>>do { 		if ( minute < (0) ||  minute > ( 59)) 			return (ISC_R_RANGE); 	} while (0);>>>do { 		if ( second < (0) ||  second > ( 60)) 			return (ISC_R_RANGE); 	} while (0);
bind/lib/dns,time.c,for,4,for (i = 0; i < 14; i++) {>>>for (i = 0; i < (month - 1); i++)>>>for (i = 1969; i >= year; i--) {>>>for (i = 1970; i < year; i++) {
bind/lib/dns,timer.c,while,2,"do { result = (isc_time_nowplusinterval(&expires, &maxinterval));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_timer_reset(timer, isc_timertype_once, 			      &expires, &idleinterval, 			      purge));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);"
bind/lib/dns,tkey.c,while,71,"do { 	result = (dns_message_gettemprdata(msg, &newrdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(msg->mctx, &tmprdatabuf, r.length)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettempname(msg, &newname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_name_dup(name, msg->mctx, newname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdatalist(msg, &newlist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdataset(msg, &newset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdatalist_tordataset(newlist, newset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (!ISC_LIST_EMPTY(*namelist)) {>>>while (!ISC_LIST_EMPTY(name->list)) {>>>do { 	result = (add_rdata_to_list(msg, keyname, &keyrdata, ttl, namelist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_todns(tctx->dhkey, &ourkeybuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (add_rdata_to_list(msg, &ourname, &ourkeyrdata, 0, namelist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_secretsize(tctx->dhkey, &sharedsize)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(msg->mctx, &shared, sharedsize)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (compute_secret(shared, &r2, &r, &secret)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_tsigkey_create(name, &tkeyin->algorithm, 				  isc_buffer_base(&secret), 				  isc_buffer_usedlength(&secret), 				  ISC_TRUE, signer, tkeyin->inception, 				  tkeyin->expire, ring->mctx, ring, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_fromgssapi(name, gss_ctx, ring->mctx, 					  &dstkey, &intoken)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_tsigkey_createfromkey(name, &tkeyin->algorithm, 						 dstkey, ISC_TRUE, 						 dns_fixedname_name(&principal), 						 now, expire, ring->mctx, ring, 						 NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rdata, &tkeyin, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (process_dhtkey(msg, signer, keyname, &tkeyin, 					      tctx, &tkeyout, ring, 					      &namelist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (process_gsstkey(keyname, &tkeyin, tctx, 					       &tkeyout, ring)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (process_deletetkey(signer, keyname, &tkeyin, 						  &tkeyout, ring)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (add_rdata_to_list(msg, keyname, &rdata, 0, &namelist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_reply(msg, ISC_TRUE)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (name != NULL) {>>>do { 	result = (dns_message_gettempname(msg, &qname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettempname(msg, &aname)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdataset(msg, &question)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(msg->mctx, &dynbuf, 4096)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdata(msg, &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_fromstruct(rdata, dns_rdataclass_any, 				    dns_rdatatype_tkey, tkey, dynbuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdatalist(msg, &tkeylist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdataset(msg, &tkeyset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdatalist_tordataset(tkeylist, tkeyset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (buildquery(msg, name, &tkey, ISC_FALSE)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_gettemprdata(msg, &rdata)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(msg->mctx, &dynbuf, 1024)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_todns(key, dynbuf)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (add_rdata_to_list(msg, &keyname, rdata, 0, &namelist)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (buildquery(msg, name, &tkey, win2k)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { 	result = (find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(qmsg, &tempname, &qtkeyrdata, 			 DNS_SECTION_ADDITIONAL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_message_findname(rmsg, DNS_SECTION_ANSWER, &keyname, 				    dns_rdatatype_key, 0, &ourkeyname, 				    &ourkeyset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { 	result = (dns_rdataset_first(theirkeyset)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_dnssec_keyfromrdata(theirkeyname, &theirkeyrdata, 				       rmsg->mctx, &theirkey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_secretsize(key, &sharedsize)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (isc_buffer_allocate(rmsg->mctx, &shared, sharedsize)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_computesecret(theirkey, key, shared)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (compute_secret(shared, &r2, &r, &secret)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_gssapi_initctx(gname, &intoken, outtoken, context, 				  ring->mctx, err_message)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_fromgssapi(dns_rootname, *context, rmsg->mctx, 				  &dstkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_tsigkey_createfromkey(tkeyname, DNS_TSIG_GSSAPI_NAME, 					 dstkey, ISC_FALSE, NULL, 					 rtkey.inception, rtkey.expire, 					 ring->mctx, ring, outkey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(qmsg, &tempname, &qtkeyrdata, 			 DNS_SECTION_ADDITIONAL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_tsigkey_find(&tsigkey, tkeyname, &rtkey.algorithm, ring)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(rmsg, &tkeyname, &rtkeyrdata, DNS_SECTION_ANSWER)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&rtkeyrdata, &rtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(qmsg, &tkeyname, &qtkeyrdata, 				 DNS_SECTION_ANSWER)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (find_tkey(qmsg, &tkeyname, &qtkeyrdata, 				 DNS_SECTION_ADDITIONAL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_rdata_tostruct(&qtkeyrdata, &qtkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dst_key_fromgssapi(dns_rootname, *context, rmsg->mctx, 				  &dstkey, NULL)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);>>>do { 	result = (dns_tsigkey_createfromkey(tkeyname, 					 (win2k 					  ? DNS_TSIG_GSSAPIMS_NAME 					  : DNS_TSIG_GSSAPI_NAME), 					 dstkey, ISC_TRUE, NULL, 					 rtkey.inception, rtkey.expire, 					 ring->mctx, ring, outkey)); 	if (result != ISC_R_SUCCESS) 		goto failure; 	} while (0);"
bind/lib/dns,tkey.c,for,5,"for (i = 0; i < sizeof(digests); i++)>>>for (i = 0; i < r2.length; i++)>>>for (result = dns_message_firstname(msg, DNS_SECTION_ADDITIONAL);>>>for (result = dns_rdataset_first(keyset);>>>for (i = 0, j = 0; i < sizeof(randomdata); i++) {"
bind/lib/dns,tsig.c,while,2,while (refs-- > 0)>>>} while (result == ISC_R_SUCCESS);
bind/lib/dns,tsig.c,for,2,for (;;) {>>>for (;;) {
bind/lib/dns,ttl.c,while,7,"do { 	isc_result_t _r = (ttlfmt(weeks, ""week"", verbose, ISC_TF(x > 0), target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (ttlfmt(days, ""day"", verbose, ISC_TF(x > 0), target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (ttlfmt(hours, ""hour"", verbose, ISC_TF(x > 0), target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (ttlfmt(mins, ""minute"", verbose, ISC_TF(x > 0), target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (ttlfmt(secs, ""second"", verbose, ISC_TF(x > 0), target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>while (*s != '\0' && isdigit((unsigned char)*s))>>>} while (*s != '\0');"
bind/lib/dns,update.c,while,87,"do { result = (dns_difftuple_create(list->mctx, DNS_DIFFOP_EXISTS, name, 0, 				   &dummy_rdata, &tuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_createiterator(db, DNS_DB_NONSEC3, &dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_current(dbit, &node, child)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (namelist_append_name(affected, child)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_diff_sort(list, name_order)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (p != NULL) {>>>} while (1);>>>do { result = (dns_db_createiterator(db, 0, &dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_seek(dbit, oldname)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_first(dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_last(dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_current(dbit, &node, newname)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_pause(dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, ver, newname, 					   dns_rdatatype_nsec, 0, &has_nsec)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>} while (! has_nsec);>>>do { result = (next_active(log, zone, db, ver, name, target, ISC_TRUE)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnode(db, name, ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec_buildrdata(db, ver, node, target, buffer, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_if(true_p, db, ver, name, dns_rdatatype_nsec, 0, 			NULL, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, name, 				   nsecttl, &rdata, &tuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&tuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, name, 0, 				   &rdata, &tuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&tuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnode(db, dns_db_origin(db), ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dnssec_findzonekeys2(db, ver, node, dns_db_origin(db), 				       directory, mctx, maxkeys, keys, nkeys)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnsec3node(db, name, ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnode(db, name, ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findrdataset(db, node, ver, type, 0, 				  (isc_stdtime_t) 0, &rdataset, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dnssec_sign(name, &rdataset, keys[i], 				      &inception, &expire, 				      mctx, &buffer, &sig_rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_ADDRESIGN, name, 				    rdataset.ttl, &sig_rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnode(db, dns_db_origin(db), ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findrdataset(db, node, newver, dns_rdatatype_soa, 0, 				  (isc_stdtime_t) 0, &rdataset, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdataset_first(&rdataset)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &soa, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_diff_sort(diff, temp_order)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (t != NULL) {>>>do { result = (namelist_append_name(&diffnames, name)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (t != NULL && dns_name_equal(&t->name, name)) {>>>do { result = (delete_if(true_p, db, newver, name, 						dns_rdatatype_rrsig, type, 						NULL, &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_visible(db, newver, name, type, &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_sigs(log, zone, db, newver, name, 					       type, &sig_diff, zone_keys, 					       nkeys, inception, expire, 					       check_ksk, keyset_kskonly)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (non_nsec_rrset_exists(db, newver, &t->name, &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_if(true_p, db, newver, &t->name, 					dns_rdatatype_any, 0, 					NULL, &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_private_chains(db, newver, privatetype, &build_nsec, 				 &build_nsec3)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (name_exists(db, oldver, &t->name, &existed)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (name_exists(db, newver, &t->name, &exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (next_active(log, zone, db, newver, 				  &t->name, prevname, ISC_FALSE)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (namelist_append_name(&affected, prevname)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, oldver, &t->name, 					  dns_rdatatype_ns, 0, &ns_existed)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, oldver, &t->name, 					   dns_rdatatype_dname, 0, 					   &dname_existed)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, &t->name, dns_rdatatype_ns, 0, 				   &ns_exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, &t->name, dns_rdatatype_dname, 0, 				   &dname_exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (namelist_append_subdomain(db, &t->name, &affected)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (uniqify_name_list(&affected)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (name_exists(db, newver, name, &exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (is_active(db, newver, name, &flag, &cut, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_if(true_p, db, newver, name, 					dns_rdatatype_nsec, 0, 					NULL, &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_if(rrsig_p, db, newver, name, 					dns_rdatatype_any, 0, NULL, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, name, 						   dns_rdatatype_nsec, 0, 						   &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_placeholder_nsec(db, newver, 								   name, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_exposed_sigs(log, zone, db, newver, name, 					       cut, &sig_diff, zone_keys, nkeys, 					       inception, expire, check_ksk, 					       keyset_kskonly)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, &t->name, 				   dns_rdatatype_nsec, 0, &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_nsec(log, zone, db, newver, &t->name, 				       nsecttl, &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while ((t = ISC_LIST_HEAD(nsec_diff.tuples)) != NULL) {>>>do { result = (delete_if(true_p, db, newver, &t->name, 					dns_rdatatype_rrsig, dns_rdatatype_nsec, 					NULL, &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_sigs(log, zone, db, newver, &t->name, 				       dns_rdatatype_nsec, &sig_diff, 				       zone_keys, nkeys, inception, expire, 				       check_ksk, keyset_kskonly)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while ((t = ISC_LIST_HEAD(sig_diff.tuples)) != NULL) {>>>while ((t = ISC_LIST_HEAD(nsec_mindiff.tuples)) != NULL) {>>>do { result = (dns_diff_sort(diff, temp_order)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (t != NULL) {>>>do { result = (namelist_append_name(&affected, name)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, oldver, name, dns_rdatatype_ns, 					   0, &ns_existed)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, oldver, name, 					   dns_rdatatype_dname, 0, 					   &dname_existed)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, name, dns_rdatatype_ns, 0, 				   &ns_exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rrset_exists(db, newver, name, dns_rdatatype_dname, 0, 				   &dname_exists)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (namelist_append_subdomain(db, name, &affected)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (t != NULL && dns_name_equal(&t->name, name))>>>do { result = (is_active(db, newver, name, &flag, &cut, &unsecure)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_if(rrsig_p, db, newver, name, 					dns_rdatatype_any, 0, NULL, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_delnsec3sx(db, newver, name, 						   privatetype, &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_exposed_sigs(log, zone, db, newver, name, 					       cut, &sig_diff, zone_keys, nkeys, 					       inception, expire, check_ksk, 					       keyset_kskonly)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_addnsec3sx(db, newver, name, nsecttl, 						   unsecure, privatetype, 						   &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while ((t = ISC_LIST_HEAD(nsec_diff.tuples)) != NULL) {>>>do { result = (delete_if(true_p, db, newver, &t->name, 					dns_rdatatype_rrsig, 					dns_rdatatype_nsec3, 					NULL, &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_sigs(log, zone, db, newver, &t->name, 				       dns_rdatatype_nsec3, 				       &sig_diff, zone_keys, nkeys, 				       inception, expire, check_ksk, 				       keyset_kskonly)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while ((t = ISC_LIST_HEAD(sig_diff.tuples)) != NULL) {>>>while ((t = ISC_LIST_HEAD(nsec_mindiff.tuples)) != NULL) {"
bind/lib/dns,update.c,for,18,"for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdatasetiter_first(iter);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_dbiterator_seek(dbit, name);>>>for (i = 0; i < nkeys; i++) {>>>for (j = 0; j < nkeys; j++) {>>>for (result = dns_rdataset_first(&rdataset);>>>for (i = 0; i < nkeys; i++) {>>>for (result = dns_rdatasetiter_first(iter);>>>for (t = ISC_LIST_HEAD(diffnames.tuples);>>>for (t = ISC_LIST_HEAD(diffnames.tuples);>>>for (t = ISC_LIST_HEAD(diffnames.tuples);>>>for (t = ISC_LIST_HEAD(affected.tuples);>>>for (t = ISC_LIST_HEAD(affected.tuples);>>>for (t = ISC_LIST_HEAD(nsec_mindiff.tuples);>>>for (t = ISC_LIST_HEAD(affected.tuples);>>>for (t = ISC_LIST_HEAD(nsec_mindiff.tuples);>>>for (i = 0; i < nkeys; i++)"
bind/lib/dns,validator.c,while,6,while (qlabels >= zlabels) {>>>} while (result == ISC_R_SUCCESS);>>>} while (1);>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_NOSPACE) {>>>while (dns_name_countlabels(dlvname) >=
bind/lib/dns,validator.c,for,18,"for (result = dns_rdataset_first(&val->dlv);>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(&set);>>>for (parent = val; parent != NULL; parent = parent->parent) {>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(sigrdataset);>>>for (result = dns_rdataset_first(val->event->sigrdataset);>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(&val->dlv);>>>for (result = dns_rdataset_first(&val->dlv);>>>for (result = dns_rdataset_first(val->event->sigrdataset);>>>for (result = dns_rdataset_first(val->dsset);>>>for (result = dns_rdataset_first(val->dsset);>>>for (result = val_rdataset_first(val, &name, &rdataset);>>>for (result = val_rdataset_first(val, &name, &rdataset);>>>for (result = val_rdataset_first(val, &name, &rdataset);>>>for (sigrdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);"
bind/lib/dns,view.c,while,6,"while (name != NULL) {>>>while (name != NULL) {>>>while (new != NULL && !dns_name_equal(new, name))>>>while (new != NULL && !dns_name_equal(new, name))>>>while (new != NULL && !dns_name_equal(new, name))>>>while (new != NULL && !dns_name_equal(new, name))"
bind/lib/dns,view.c,for,5,for (i = 0; i < 111; i++) {>>>for (i = 0; i < 111; i++) {>>>for (view = ISC_LIST_HEAD(*list);>>>for (hash = 0; hash < 111; hash++)>>>for (hash = 0; hash < 111; hash++)
bind/lib/dns,xfrin.c,while,82,"do { result = (axfr_makedb(xfr, &xfr->db));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_beginload(xfr->db, &xfr->axfr.add_func, 			       &xfr->axfr.add_private));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_zone_checknames(xfr->zone, name, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_difftuple_create(xfr->diff.mctx, op, 				   name, ttl, rdata, &tuple));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_apply(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_diff_load(&xfr->diff, 			    xfr->axfr.add_func, xfr->axfr.add_private));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_apply(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_endload(xfr->db, &xfr->axfr.add_private));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_zone_replacedb(xfr->zone, xfr->db, ISC_TRUE));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_journal_open(xfr->mctx, journalfile, 				       DNS_JOURNAL_CREATE, &xfr->ixfr.journal));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_zone_checknames(xfr->zone, name, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_difftuple_create(xfr->diff.mctx, op, 				   name, ttl, rdata, &tuple));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_apply(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_newversion(xfr->db, &xfr->ver));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_journal_begin_transaction(xfr->ixfr.journal));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_diff_apply(&xfr->diff, xfr->db, xfr->ver));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_apply(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_journal_commit(xfr->ixfr.journal));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_UPTODATE);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_UPTODATE);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_init(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_init(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_putdata(xfr, DNS_DIFFOP_DEL, name, ttl, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_putdata(xfr, DNS_DIFFOP_DEL, name, ttl, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_putdata(xfr, DNS_DIFFOP_ADD, name, ttl, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_commit(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_FORMERR);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_commit(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_INVALIDNS);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (ixfr_putdata(xfr, DNS_DIFFOP_ADD, name, ttl, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_putdata(xfr, DNS_DIFFOP_ADD, name, ttl, rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_commit(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_EXTRADATA);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (xfrin_create(mctx, zone, db, task, timermgr, socketmgr, zonename, 			   dns_zone_getclass(zone), xfrtype, masteraddr, 			   sourceaddr, tsigkey, &xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (xfrin_start(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_name_dup(zonename, mctx, &xfr->name));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_timer_create(timermgr, isc_timertype_inactive, NULL, NULL, 			       task, xfrin_timeout, xfr, &xfr->timer));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_timer_setidle(xfr->timer, 				dns_zone_getmaxxfrin(xfr->zone), 				dns_zone_getidlein(xfr->zone), 				ISC_FALSE));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_socket_create(xfr->socketmgr, 				isc_sockaddr_pf(&xfr->sourceaddr), 				isc_sockettype_tcp, 				&xfr->socket));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_socket_bind(xfr->socket, &xfr->sourceaddr, 			      ISC_SOCKET_REUSEADDRESS));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_socket_connect(xfr->socket, &xfr->masteraddr, xfr->task, 				 xfrin_connect_done, xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_compress_init(&cctx, -1, mctx));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_renderbegin(msg, &cctx, buf));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_rendersection(msg, DNS_SECTION_QUESTION, 0));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_rendersection(msg, DNS_SECTION_ANSWER, 0));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_rendersection(msg, DNS_SECTION_AUTHORITY, 0));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_rendersection(msg, DNS_SECTION_ADDITIONAL, 0));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_renderend(msg));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (xfrin_send_request(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettemprdata(msg, &rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettemprdatalist(msg, &rdl));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettemprdataset(msg, &rds));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_rdatalist_tordataset(rdl, rds));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettempname(msg, &name));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_create(xfr->mctx, DNS_MESSAGE_INTENTRENDER, &msg));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_settsigkey(msg, xfr->tsigkey));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettempname(msg, &qname));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_gettemprdataset(msg, &qrdataset));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_createsoatuple(xfr->db, ver, xfr->mctx, 					    DNS_DIFFOP_EXISTS, &soatuple));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (tuple2msgname(soatuple, msg, &msgsoaname));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_db_getsoaserial(xfr->db, NULL, 					  &xfr->ixfr.request_serial));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (render(msg, xfr->mctx, &xfr->qbuffer));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_getquerytsig(msg, xfr->mctx, &xfr->lasttsig));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_socket_send(xfr->socket, &lregion, xfr->task, 			      xfrin_sendlen_done, xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (evresult);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_socket_send(xfr->socket, &region, xfr->task, 			      xfrin_send_done, xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (sev->result);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_tcpmsg_readmessage(&xfr->tcpmsg, xfr->task, 				     xfrin_recv_done, xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (tcpmsg->result);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (isc_timer_touch(xfr->timer));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_create(xfr->mctx, DNS_MESSAGE_INTENTPARSE, &msg));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_settsigkey(msg, xfr->tsigkey));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_setquerytsig(msg, xfr->lasttsig));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (DNS_R_NOTAUTHORITATIVE);							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (xfr_rr(xfr, name, rds->ttl, &rdata));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_message_getquerytsig(msg, xfr->mctx, 					       &xfr->lasttsig));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (xfrin_send_request(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (axfr_finalize(xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);>>>do { result = (dns_tcpmsg_readmessage(&xfr->tcpmsg, xfr->task, 					     xfrin_recv_done, xfr));							if (result != ISC_R_SUCCESS) goto failure;		} while (0);"
bind/lib/dns,xfrin.c,for,3,"for (result = dns_message_firstname(msg, DNS_SECTION_ANSWER);>>>for (rds = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rds);"
bind/lib/dns,zone.c,while,563,"do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone->raw)->lock); 	      INSIST((zone->raw)->locked == ISC_FALSE); 	     (zone->raw)->locked = ISC_TRUE; 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x08000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00002000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x08000000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone->raw)->locked = ISC_FALSE; UNLOCK(&(zone->raw)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x10000000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (ISC_R_NOMEMORY); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (ISC_R_NOMEMORY); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x10000000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( then - now), 0); 		if (isc_time_add((&timenow), &_i, ( &timethen)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # then - now); 			isc_interval_set(&_i, ( then - now)/2, 0); 			(void)isc_time_add((&timenow), &_i, ( &timethen)); 		} 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { result = (dst_key_todns(key, &dstb)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &dnskey, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_keydata_fromdnskey(&keydata, &dnskey, now, 0, 0, 					     NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_fromstruct(&rdata, 					   zone->rdclass, dns_rdatatype_keydata, 					   &keydata, &keyb)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_ADD, 				    dst_key_name(key), 0, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dnssec_keyfromrdata(keyname, &rdata, mctx, &dstkey)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_keytable_add(sr, ISC_TRUE, &dstkey)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_createsoatuple(db, ver, mctx, DNS_DIFFOP_DEL, &deltuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_copy(deltuple, &addtuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&deltuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&addtuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_view_getsecroots(view, &sr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_keydata(db, ver, &diff, 					     rrname, rdataset)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (result == DNS_R_NEWORIGIN || result == ISC_R_SUCCESS) {>>>do { result = (update_soa_serial(db, ver, &diff, zone->mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, NULL, ""sync_keyzone"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { result = (dns_zone_getdb(zone, &db)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone->raw)->locked)); 		(zone->raw)->flags |= ( 0x40000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000010U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000010U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00004000U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->expire), 0); 		if (isc_time_add((&t), &_i, ( 						  &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->expire); 			isc_interval_set(&_i, ( zone->expire)/2, 0); 			(void)isc_time_add((&t), &_i, ( 						  &zone->expiretime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->retry), 0); 		if (isc_time_add((&now), &_i, ( 						  &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->retry); 			isc_interval_set(&_i, ( zone->retry)/2, 0); 			(void)isc_time_add((&now), &_i, ( 						  &zone->expiretime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( delay), 0); 		if (isc_time_add((&now), &_i, ( &zone->refreshtime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # delay); 			isc_interval_set(&_i, ( delay)/2, 0); 			(void)isc_time_add((&now), &_i, ( &zone->refreshtime)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 				 0x00000020U|0x00000400U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x10000000U); 		} while (0);>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(source)->lock); 	      INSIST((source)->locked == ISC_FALSE); 	     (source)->locked = ISC_TRUE; 		} while (0);>>>do { (source)->locked = ISC_FALSE; UNLOCK(&(source)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( flags); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( flags); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00001000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000008U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000002U); 		} while (0);>>>do { result = (dns_db_findnode(db, dns_db_origin(db), ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dnssec_sign(name, &rdataset, keys[i], 				      &inception, &expire, 				      mctx, &buffer, &sig_rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_ADDRESIGN, 				    name, rdataset.ttl, &sig_rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { result = (zone_journal(zone, &sig_diff, NULL, ""zone_resigninc"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (dns_db_createiterator(db, DNS_DB_NONSEC3, &dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_seek(dbit, oldname)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_first(dbit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dbiterator_current(dbit, &node, newname)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_allrdatasets(db, node, version, 0, &rdsit)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>} while (1);>>>do { result = (next_active(db, version, name, next, bottom)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec_buildrdata(db, version, node, next, nsecbuffer, 				  &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, version, diff, DNS_DIFFOP_ADD, name, ttl, 			    &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_addnsec3s(db, version, name, minimum, 					  unsecure, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_nsec(db, version, name, node, minimum, 				       bottom, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { result = (dns_dnssec_sign(name, &rdataset, key, &inception, 				      &expire, mctx, &buffer, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, version, diff, DNS_DIFFOP_ADDRESIGN, 				    name, rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_getoriginnode(db, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (delete_nsec(db, version, node, name, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_nsec(db, version, name, node, minimum, ISC_FALSE, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(signing->db, version, diff, 					    DNS_DIFFOP_DEL, &zone->origin, 					    rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(signing->db, version, diff, DNS_DIFFOP_ADD, 				    &zone->origin, rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_addnsec3s(signing->db, version, origin, 						  minimum, ISC_FALSE, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (updatesecure(signing->db, version, origin, minimum, 				   ISC_TRUE, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_DEL, 				    name, rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &nsec3param, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_DEL, 				    name, rdataset.ttl, &private)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_fromstruct(&rdata, dns_db_class(db), 				   dns_rdatatype_nsec3param, 				   &chain->nsec3param, &buffer)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_ADD, name, ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_DEL, name, 				    rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &nsec3, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, ver, diff, DNS_DIFFOP_DEL, name, 				    rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &myparam, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>} while (tuple != NULL);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (nsec3chain != NULL && nodes-- > 0 && signatures > 0) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (delete_nsec(db, version, node, name, &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (fixup_nsec3param(db, version, nsec3chain, 						       ISC_FALSE, privatetype, 						       &param_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (fixup_nsec3param(db, version, 							       nsec3chain, 							       ISC_TRUE, 							       privatetype, 							       &param_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (fixup_nsec3param(db, version, nsec3chain, 						       ISC_FALSE, privatetype, 						       &param_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>} while (1);>>>do { result = (dns_dbiterator_first(nsec3chain->dbiterator)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (nsec3chain != NULL && nodes-- > 0 && signatures > 0) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (add_nsec(db, version, name, node, zone->minimum, 				       delegation, &nsec_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>} while (1);>>>do { result = (dns_dbiterator_first(nsec3chain->dbiterator)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &sig_diff, NULL, ""zone_nsec3chain"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (nsec3chain != NULL) {>>>while (nsec3chain != NULL) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (update_one_rr(db, version, diff, 						    DNS_DIFFOP_DEL, name, 						    rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &rrsig, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, version, diff, 					    DNS_DIFFOP_DELRESIGN, name, 					    rdataset.ttl, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_private_chains(db, version, zone->privatetype, 				 &build_nsec, &build_nsec3)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (signing != NULL && nodes-- > 0 && signatures > 0) {>>>do { result = (del_sig(db, version, name, node, nkeys, 				      signing->algorithm, signing->keyid, 				      &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (sign_a_node(db, name, node, version, build_nsec3, 					  build_nsec, zone_keys[i], inception, 					  expire, zone->minimum, is_ksk, 					  ISC_TF(both && keyset_kskonly), 					  &delegation, &sig_diff, 					  &signatures, zone->mctx)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>} while (1);>>>do { result = (zone_journal(zone, &sig_diff, NULL, ""zone_sign"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (signing != NULL) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (signing != NULL) {>>>do { result = (update_one_rr(kfetch->db, ver, diff, DNS_DIFFOP_DEL, 				    name, 0, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_tostruct(&rdata, &keydata, NULL)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_rdata_fromstruct(&rdata, 					   zone->rdclass, dns_rdatatype_keydata, 					   &keydata, &keyb)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(kfetch->db, ver, diff, DNS_DIFFOP_ADD, 				    name, 0, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { result = (dns_db_newversion(kfetch->db, &ver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x04000000U); 		} while (0);>>>do { result = (minimal_update(kfetch, ver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (minimal_update(kfetch, ver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { result = (update_one_rr(kfetch->db, ver, &diff, 						    DNS_DIFFOP_DEL, keyname, 0, 						    &keydatarr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(kfetch->db, ver, &diff, 					    DNS_DIFFOP_ADD, keyname, 0, 					    &keydatarr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (compute_tag(keyname, &dnskey, 						  mctx, &tag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(kfetch->db, ver, &diff, 					    DNS_DIFFOP_DEL, keyname, 0, 					    &keydatarr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(kfetch->db, ver, &diff, 					    DNS_DIFFOP_ADD, keyname, 0, 					    &keydatarr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(kfetch->db, ver, &diff, 					    DNS_DIFFOP_ADD, keyname, 0, 					    &keydatarr)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(kfetch->db, ver, &diff, mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, NULL, ""keyfetch_done"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (dns_db_newversion(db, &ver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x04000000U); 		} while (0);>>>do { result = (update_one_rr(db, ver, &diff, 						    DNS_DIFFOP_DEL, name, ttl, 						    &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(db, ver, &diff, zone->mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, NULL, ""zone_refreshkeys"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( 3600), 0); 		if (isc_time_add((&timenow), &_i, ( &timethen)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # 3600); 			isc_interval_set(&_i, ( 3600)/2, 0); 			(void)isc_time_add((&timenow), &_i, ( &timethen)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x04000000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000080U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00004000U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00001000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00800000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00200000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		isc_interval_t _i; 		isc_uint32_t _j; 		_j = isc_random_jitter(( delay), ( delay)/4); 		isc_interval_set(&_i, _j, 0); 		if (isc_time_add((&now), &_i, ( &dumptime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # delay); 			isc_interval_set(&_i, _j/2, 0); 			(void)isc_time_add((&now), &_i, ( &dumptime)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000002U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000008U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x02000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000002U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000008U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00200000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000008U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000002U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000008U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00200000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000020U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000002U); 		} while (0);>>>do { LOCK(&(notify->zone)->lock); 	      INSIST((notify->zone)->locked == ISC_FALSE); 	     (notify->zone)->locked = ISC_TRUE; 		} while (0);>>>do { (notify->zone)->locked = ISC_FALSE; UNLOCK(&(notify->zone)->lock); } while (0);>>>do { LOCK(&(notify->zone)->lock); 	      INSIST((notify->zone)->locked == ISC_FALSE); 	     (notify->zone)->locked = ISC_TRUE; 		} while (0);>>>do { (notify->zone)->locked = ISC_FALSE; UNLOCK(&(notify->zone)->lock); } while (0);>>>do { LOCK(&(notify->zone)->lock); 	      INSIST((notify->zone)->locked == ISC_FALSE); 	     (notify->zone)->locked = ISC_TRUE; 		} while (0);>>>do { (notify->zone)->locked = ISC_FALSE; UNLOCK(&(notify->zone)->lock); } while (0);>>>do { LOCK(&(notify->zone)->lock); 	      INSIST((notify->zone)->locked == ISC_FALSE); 	     (notify->zone)->locked = ISC_TRUE; 		} while (0);>>>do { (notify->zone)->locked = ISC_FALSE; UNLOCK(&(notify->zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000400U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->notifydelay), 0); 		if (isc_time_add((now), &_i, ( &zone->notifytime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->notifydelay); 			isc_interval_set(&_i, ( zone->notifydelay)/2, 0); 			(void)isc_time_add((now), &_i, ( &zone->notifytime)); 		} 	} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000004U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00004000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_uint32_t _j; 		_j = isc_random_jitter(( zone->refresh), ( zone->refresh)/4); 		isc_interval_set(&_i, _j, 0); 		if (isc_time_add((&now), &_i, ( &zone->refreshtime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->refresh); 			isc_interval_set(&_i, _j/2, 0); 			(void)isc_time_add((&now), &_i, ( &zone->refreshtime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->expire), 0); 		if (isc_time_add((&now), &_i, ( &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->expire); 			isc_interval_set(&_i, ( zone->expire)/2, 0); 			(void)isc_time_add((&now), &_i, ( &zone->expiretime)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00800000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 						     0x01000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x01000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000004U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_uint32_t _j; 		_j = isc_random_jitter(( zone->refresh), ( zone->refresh)/4); 		isc_interval_set(&_i, _j, 0); 		if (isc_time_add((&now), &_i, ( &zone->refreshtime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->refresh); 			isc_interval_set(&_i, _j/2, 0); 			(void)isc_time_add((&now), &_i, ( &zone->refreshtime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->expire), 0); 		if (isc_time_add((&now), &_i, ( &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->expire); 			isc_interval_set(&_i, ( zone->expire)/2, 0); 			(void)isc_time_add((&now), &_i, ( &zone->expiretime)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00800000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000100U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00800000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00400000U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000040U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00080000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000100U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (result == ISC_R_SUCCESS) {>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (dns_journal_iter_init(journal, start, end)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, 							   DNS_DIFFOP_ADD, 							   name, ttl, rdata, 							   soatuplep)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, op, name, ttl, rdata, 					   &tuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_newversion(db, &newver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (sync_secure_db(zone, db, oldver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_diff_apply(&diff, db, newver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_createsoatuple(db, oldver, diff.mctx, 					    DNS_DIFFOP_DEL, &tuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&tuple, db, newver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&soatuple, db, newver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(db, newver, &diff, zone->mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_update_signatures(&log, zone, db, oldver, newver, 				    &diff, zone->sigvalidityinterval)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, &end, ""receive_secure_serial"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x40000000U); 		} while (0);>>>do { LOCK(&(zone->raw)->lock); 	      INSIST((zone->raw)->locked == ISC_FALSE); 	     (zone->raw)->locked = ISC_TRUE; 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone->raw)->locked = ISC_FALSE; UNLOCK(&(zone->raw)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x40000000U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x20000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U|0x00000400U); 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x01000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00008000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00004000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00004000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00000100U); 		} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->expire), 0); 		if (isc_time_add((&now), &_i, ( 					  &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->expire); 			isc_interval_set(&_i, ( zone->expire)/2, 0); 			(void)isc_time_add((&now), &_i, ( 					  &zone->expiretime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_uint32_t _j; 		_j = isc_random_jitter(( zone->refresh), ( zone->refresh)/4); 		isc_interval_set(&_i, _j, 0); 		if (isc_time_add((&now), &_i, ( 					    &zone->refreshtime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->refresh); 			isc_interval_set(&_i, _j/2, 0); 			(void)isc_time_add((&now), &_i, ( 					    &zone->refreshtime)); 		} 	} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->expire), 0); 		if (isc_time_add((&now), &_i, ( 					  &zone->expiretime)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->expire); 			isc_interval_set(&_i, ( zone->expire)/2, 0); 			(void)isc_time_add((&now), &_i, ( 					  &zone->expiretime)); 		} 	} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x20000000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00100000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00800000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00800000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000001U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x02000000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone->raw)->lock); 	      INSIST((zone->raw)->locked == ISC_FALSE); 	     (zone->raw)->locked = ISC_TRUE; 		} while (0);>>>do { LOCK(&(load->zone)->lock); 	      INSIST((load->zone)->locked == ISC_FALSE); 	     (load->zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((load->zone)->locked)); 		(load->zone)->flags &= ~( 0x00002000U); 		} while (0);>>>do { 		INSIST(((load->zone)->locked)); 		(load->zone)->flags &= ~( 0x08000000U); 		} while (0);>>>do { (load->zone)->locked = ISC_FALSE; UNLOCK(&(load->zone)->lock); } while (0);>>>do { (zone->raw)->locked = ISC_FALSE; UNLOCK(&(zone->raw)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00100000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(forward->zone)->lock); 	      INSIST((forward->zone)->locked == ISC_FALSE); 	     (forward->zone)->locked = ISC_TRUE; 		} while (0);>>>do { (forward->zone)->locked = ISC_FALSE; UNLOCK(&(forward->zone)->lock); } while (0);>>>do { (forward->zone)->locked = ISC_FALSE; UNLOCK(&(forward->zone)->lock); } while (0);>>>do { (forward->zone)->locked = ISC_FALSE; UNLOCK(&(forward->zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(x)->lock); 	      INSIST((x)->locked == ISC_FALSE); 	     (x)->locked = ISC_TRUE; 		} while (0);>>>do { (x)->locked = ISC_FALSE; UNLOCK(&(x)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00008000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags &= ~( 0x00020000U | 			 0x00040000U | 			 0x00010000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= (	(0x00020000U | 				 0x00040000U | 				 0x00010000U)); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00020000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00020000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00010000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00040000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00010000U); 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00010000U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>while (!ISC_LIST_EMPTY(*list)) {>>>do { result = (dns_db_findnsec3node(db, name, ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findnode(db, name, ISC_FALSE, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rr_exists(db, ver, name, &rdata, &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_ADD, 						   name, 0, &rdata, &newtuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&newtuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (rr_exists(db, ver, name, &rdata, &flag)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_difftuple_create(diff->mctx, DNS_DIFFOP_DEL, 						   name, 0, &rdata, &newtuple)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (do_one_tuple(&newtuple, db, ver, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (result); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_activex(db, ver, ISC_FALSE, 					privatetype, &nsec3)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_getoriginnode(db, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_private_chains(db, ver, zone->privatetype, NULL, 				 &build_nsec3)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3_addnsec3sx(db, ver, origin, zone->minimum, 					   ISC_FALSE, zone->privatetype, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (updatesecure(db, ver, origin, zone->minimum, ISC_TRUE, diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_zone_getdb(zone, &db)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_newversion(db, &ver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_getoriginnode(db, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_db_findrdataset(db, node, ver, dns_rdatatype_soa, 				  dns_rdatatype_none, 0, &soaset, &soasigs)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_dnssec_keylistfromrdataset(&zone->origin, dir, 						     mctx, &keyset, 						     &keysigs, &soasigs, 						     ISC_FALSE, ISC_FALSE, 						     &dnskeys)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_diff_apply(&diff, db, ver)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (clean_nsec3param(zone, db, ver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_signing_records(db, zone->privatetype, 						  ver, &diff, 						  ISC_TF(newalg || fullsign))); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(db, ver, &diff, mctx, 						zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (add_chains(zone, db, ver, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (sign_apex(zone, db, ver, &diff, &sig_diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &sig_diff, NULL, 					   ""zone_rekey"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000400U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( zone->refreshkeyinterval), 0); 		if (isc_time_add((&timenow), &_i, ( 				  &timethen)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # zone->refreshkeyinterval); 			isc_interval_set(&_i, ( zone->refreshkeyinterval)/2, 0); 			(void)isc_time_add((&timenow), &_i, ( 				  &timethen)); 		} 	} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { 		isc_interval_t _i; 		isc_interval_set(&_i, ( then - now), 0); 		if (isc_time_add((&timenow), &_i, ( &timethen)) != ISC_R_SUCCESS) { 			dns_zone_log(zone, ISC_LOG_WARNING, 				     ""epoch approaching: upgrade required: "" 				     ""now + %s failed"", # then - now); 			isc_interval_set(&_i, ( then - now)/2, 0); 			(void)isc_time_add((&timenow), &_i, ( &timethen)); 		} 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone->raw)->lock); 	      INSIST((zone->raw)->locked == ISC_FALSE); 	     (zone->raw)->locked = ISC_TRUE; 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (zone->raw)->locked = ISC_FALSE; UNLOCK(&(zone->raw)->lock); } while (0);>>>do { LOCK(&(raw)->lock); 	      INSIST((raw)->locked == ISC_FALSE); 	     (raw)->locked = ISC_TRUE; 		} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { (raw)->locked = ISC_FALSE; UNLOCK(&(raw)->lock); } while (0);>>>do { result = (update_one_rr(db, newver, &diff, DNS_DIFFOP_DEL, 					    &zone->origin, rdataset.ttl, 					    &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(db, newver, &diff, zone->mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (result); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, NULL, ""keydone"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { result = (ISC_R_FAILURE); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (ISC_R_FAILURE); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_secalg_fromtext(&alg, &r)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { result = (dns_db_getoriginnode(db, &node)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (dns_nsec3param_deletechains(db, newver, zone, 						  !np->nsec, &diff)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_one_rr(db, newver, &diff, DNS_DIFFOP_ADD, 				    &zone->origin, 0, &rdata)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (update_soa_serial(db, newver, &diff, zone->mctx, 					zone->updatemethod)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (result); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { result = (zone_journal(zone, &diff, NULL, ""setnsec3param"")); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { 		INSIST(((zone)->locked)); 		(zone)->flags |= ( 0x00000020U); 		} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);>>>do { LOCK(&(zone)->lock); 	      INSIST((zone)->locked == ISC_FALSE); 	     (zone)->locked = ISC_TRUE; 		} while (0);>>>do { result = (dns_rdata_fromstruct(&nrdata, zone->rdclass, 					   dns_rdatatype_nsec3param, 					   &param, &b)); 		if (result != ISC_R_SUCCESS) goto failure; 	} while (0);>>>do { (zone)->locked = ISC_FALSE; UNLOCK(&(zone)->lock); } while (0);"
bind/lib/dns,zone.c,for,112,"for (signing = ISC_LIST_HEAD(zone->signing);>>>for (nsec3chain = ISC_LIST_HEAD(zone->nsec3chain);>>>for (i = 0; i < zone->db_argc; i++)>>>for (i = 0; i < zone->db_argc; i++)>>>for (i = 0; i < zone->db_argc; i++) {>>>for (i = 0; i < dbargc; i++)>>>for (i = 0; i < dbargc; i++) {>>>for (i = 0; i < dbargc; i++)>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(&tmprdataset);>>>for (result = dns_dbiterator_first(dbiterator);>>>for (result = dns_rdatasetiter_first(rdsit);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (i = 0; i < nsec3param->salt_length; i++)>>>for (current = ISC_LIST_HEAD(zone->nsec3chain);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rdataset_first(rdataset);>>>for (result = dns_rriterator_first(&rrit);>>>for (i = 0; i < count; i++)>>>for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++)>>>for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++)>>>for (i = 0; i < count; i++)>>>for (i = 0; i < nkeys; i++) {>>>for (i = 0; i < nkeys; i++) {>>>for (result = dns_rdataset_first(&rdataset);>>>for (i = 0; i < nkeys; i++) {>>>for (i = 0; i < nkeys; i++) {>>>for (j = 0; j < nkeys; j++) {>>>for (i = 0; i < nkeys; i++)>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdatasetiter_first(iterator);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (tuple = ISC_LIST_HEAD(diff->tuples);>>>for (result = dns_rdatasetiter_first(iterator);>>>for (result = dns_rdatasetiter_first(iterator);>>>for (result = dns_rdatasetiter_first(iterator);>>>for (nsec3chain = ISC_LIST_HEAD(zone->nsec3chain);>>>for (nsec3chain = ISC_LIST_HEAD(zone->nsec3chain);>>>for (i = 0; i < nkeys; i++)>>>for (result = dns_rdatasetiter_first(iterator);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&rdataset);>>>for (i = 0, j = 0; i < nkeys; i++) {>>>for (i = 0; i < nkeys; i++) {>>>for (j = 0; j < nkeys; j++) {>>>for (signing = ISC_LIST_HEAD(zone->signing);>>>for (signing = ISC_LIST_HEAD(cleanup);>>>for (signing = ISC_LIST_HEAD(zone->signing);>>>for (i = 0; i < nkeys; i++)>>>for (result = dns_rdataset_first(rdset);>>>for (result = dns_rdataset_first(&kfetch->keydataset);>>>for (result = dns_rdataset_first(&kfetch->dnskeysigset);>>>for (result = dns_rdataset_first(&kfetch->dnskeysigset);>>>for (result = dns_rdataset_first(&kfetch->keydataset);>>>for (result = dns_rdataset_first(&kfetch->dnskeyset);>>>for (result = dns_rriterator_first(&rrit);>>>for (result = dns_rdataset_first(kdset);>>>for (j = 0; j < zone->masterscnt; j++)>>>for (notify = ISC_LIST_HEAD(zone->notifies);>>>for (forward = ISC_LIST_HEAD(zone->forwards);>>>for (notify = ISC_LIST_HEAD(zone->notifies);>>>for (ai = ISC_LIST_HEAD(notify->find->list);>>>for (i = 0; i < zone->notifycnt; i++) {>>>for (result = dns_rdataset_first(nsrdataset);>>>for (j = 0; j < zone->masterscnt; j++)>>>for (j = 0; j < zone->masterscnt; j++)>>>for (i = 0; i < zone->masterscnt; i++) {>>>for (curr = ISC_LIST_TAIL(name->list); curr != NULL;>>>for (result = dns_journal_first_rr(journal);>>>for (tuple = ISC_LIST_HEAD(diff->tuples);>>>for (result = dns_dbiterator_first(dbiterator);>>>for (result = dns_rdatasetiter_first(rdsit);>>>for (p = ISC_LIST_HEAD(zmgr->zones);>>>for (zone = ISC_LIST_HEAD(zmgr->zones);>>>for (zone = ISC_LIST_HEAD(zmgr->waiting_for_xfrin);>>>for (x = ISC_LIST_HEAD(zmgr->xfrin_in_progress);>>>for (i = 0; i < 10U; i++) {>>>for (i = 0; i < 10U; i++) {>>>for (i = 0; i < 10U; i++) {>>>for (zone = ISC_LIST_HEAD(zmgr->xfrin_in_progress);>>>for (zone = ISC_LIST_HEAD(zmgr->waiting_for_xfrin);>>>for (zone = ISC_LIST_HEAD(zmgr->zones);>>>for (zone = ISC_LIST_HEAD(zmgr->zones);>>>for (i = 0, j = 0; i < nsec3param->salt_length; i++) {>>>for (current = ISC_LIST_HEAD(zone->signing);>>>for (i = 0; i <= DST_MAX_TIMES; i++) {>>>for (result = dns_rdataset_first(&rdataset);>>>for (tuple = ISC_LIST_HEAD(diff->tuples);>>>for (tuple = ISC_LIST_HEAD(diff->tuples);>>>for (i = 0; i < nkeys; i++)>>>for (tuple = ISC_LIST_HEAD(diff->tuples);>>>for (result = dns_rdataset_first(rdataset);>>>for (key = ISC_LIST_HEAD(dnskeys);>>>for (key = ISC_LIST_HEAD(rmkeys);>>>for (key = ISC_LIST_HEAD(dnskeys);>>>for (key = ISC_LIST_HEAD(dnskeys);>>>for (tuple = ISC_LIST_HEAD(sig_diff.tuples);>>>for (key = ISC_LIST_HEAD(dnskeys);>>>for (result = dns_rdataset_first(&rdataset);>>>for (result = dns_rdataset_first(&prdataset);>>>for (result = dns_rdataset_first(&nrdataset);"
bind/lib/dns,zt.c,while,1,while (result == DNS_R_NEWORIGIN || result == ISC_R_SUCCESS) {
bind/lib/export,nsprobe.c,while,6,"while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while (result == ISC_R_SUCCESS) {>>>while ((pns = ISC_LIST_HEAD(trans->nslist)) != ((void *)0)) {>>>while ((server = ISC_LIST_HEAD(pns->servers)) != ((void *)0)) {>>>while ((ch = getopt(argc, argv, ""c:dhv"")) != -1) {"
bind/lib/export,nsprobe.c,for,18,for (pns = ISC_LIST_HEAD(trans->nslist); pns != ((void *)0);>>>for (server = ISC_LIST_HEAD(pns->servers); server != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (pns = trans->current_ns; pns != ((void *)0);>>>for (server = ISC_LIST_HEAD(pns->servers);>>>for (pns = trans->current_ns; pns != ((void *)0);>>>for (server = ISC_LIST_HEAD(pns->servers); server != ((void *)0);>>>for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (i = 0; i < 1000; i++) {>>>for (i = 0; i < 1000; i++) {>>>for (i = 0; i < 1000; i++) {
bind/lib/export,sample-async.c,while,1,"while ((ch = getopt(argc, argv, ""s:t:"")) != -1) {"
bind/lib/export,sample-async.c,for,6,for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (i = 0; i < 100; i++) {>>>for (i = 0; i < nservers; i++) {>>>for (i = 0; i < 100; i++) {>>>for (i = 0; i < 100; i++)
bind/lib/export,sample-gai.c,for,1,for (res = res0; res; res = res->ai_next) {
bind/lib/export,sample-request.c,while,1,"while ((ch = getopt(argc, argv, ""t:"")) != -1) {"
bind/lib/export,sample-request.c,for,1,for (i = 0; i < DNS_SECTION_MAX; i++) {
bind/lib/export,sample-update.c,while,9,"while ((ch = getopt(argc, argv, ""a:k:p:r:z:"")) != -1) {>>>while ((pname = ISC_LIST_HEAD(prereqlist)) != ((void *)0)) {>>>while ((rdataset = ISC_LIST_HEAD(pname->list)) != ((void *)0)) {>>>while ((uname = ISC_LIST_HEAD(updatelist)) != ((void *)0)) {>>>while ((rdataset = ISC_LIST_HEAD(uname->list)) != ((void *)0)) {>>>while ((rdatalist = ISC_LIST_HEAD(usedrdatalists)) != ((void *)0)) {>>>while ((rdata = ISC_LIST_HEAD(rdatalist->rdata)) != ((void *)0)) {>>>while ((buf = ISC_LIST_HEAD(usedbuffers)) != ((void *)0)) {>>>while (cmdline != ((void *)0) && *cmdline != 0 &&"
bind/lib/export,sample-update.c,for,4,for (; *string != '\0'; string++) {>>>for (d = delim; (dc = *d) != '\0'; d++) {>>>for (s = string; *s != '\0'; s++) {>>>for (d = delim; (dc = *d) != '\0'; d++) {
bind/lib/export,sample.c,while,1,"while ((ch = getopt(argc, argv, ""a:es:t:k:K:"")) != -1) {"
bind/lib/export,sample.c,for,2,for (name = ISC_LIST_HEAD(namelist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);
bind/lib/irs,context.c,for,1,for (trustedkey = ISC_LIST_HEAD(*trustedkeys);
bind/lib/irs,dnsconf.c,while,1,while ((keyent = ISC_LIST_HEAD(conf->trusted_keylist)) != ((void *)0)) {
bind/lib/irs,dnsconf.c,for,2,for (element = cfg_list_first(keys);>>>for (element2 = cfg_list_first(keylist);
bind/lib/irs,getaddrinfo.c,while,5,while ((resstate = ISC_LIST_HEAD(head->resstates)) != ((void *)0)) {>>>while ((resstate = ISC_LIST_HEAD(head.resstates)) != ((void *)0)) {>>>while (order != ((void *)0)) {>>>while (ai != ((void *)0)) {>>>while (oai != ((void *)0)) {
bind/lib/irs,getaddrinfo.c,for,10,"for (i = 0; i < 2; i++) {>>>for (searchent = ISC_LIST_HEAD(*searchlist); searchent != ((void *)0);>>>for (name = ISC_LIST_HEAD(rev->answerlist); name != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(name->list);>>>for (result = dns_rdataset_first(rdataset);>>>for (rest = ISC_LIST_NEXT(resstate, link);>>>for (resstate = ISC_LIST_HEAD(head.resstates);>>>for (s = string; *s != '\0'; s++) {>>>for (d = delim; (dc = *d) != '\0'; d++)>>>for (ai_tmp = ai1; ai_tmp != ((void *)0) && ai_tmp->ai_next != ((void *)0);"
bind/lib/irs,getnameinfo.c,while,15,do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAMILY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_OVERFLOW);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_OVERFLOW);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_SYSTEM);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_OVERFLOW);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_INSECUREDATA);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_OVERFLOW);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_NONAME);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_SYSTEM);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_OVERFLOW);					if (result != 0) goto cleanup;		} while (0);
bind/lib/irs,getnameinfo.c,for,4,for (i = 0; afdl[i].a_af; i++)>>>for (ptrname = ISC_LIST_HEAD(answerlist); ptrname != ((void *)0);>>>for (rdataset = ISC_LIST_HEAD(ptrname->list);>>>for (iresult = dns_rdataset_first(rdataset);
bind/lib/irs,resconf.c,while,9,while (ch != '\n' && ch != (-1))>>>while (ch != '\n' && ch != (-1) && isspace((unsigned char)ch))>>>} while (1);>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>} while (1);>>>while ((searchentry = ISC_LIST_HEAD(conf->searchlist)) != ((void *)0)) {>>>while ((address = ISC_LIST_HEAD(conf->nameservers)) != ((void *)0)) {
bind/lib/irs,resconf.c,for,5,for (i = 0; i < 8; i++) {>>>for (idx = 0; idx < 8; idx++) {>>>for (i = 0; i < 8; i++)>>>for (i = 0; i < conf->searchnxt; i++) {>>>for (i = 0; i < 8; i++) {
bind/lib/isc,assertions.c,for,1,for (i = 0; i < nframes; i++) {
bind/lib/isc,base32.c,while,17,"while (source->length > 0) {>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(wordbreak, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (mem_tobuffer(ctx->target, buf, n)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>while (!ctx.seen_end && (ctx.length != 0)) {>>>do { 	isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, 					      isc_tokentype_string, eol)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base32_decode_char(&ctx, tr->base[i])); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base32_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base32_decode_char(&ctx, c)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base32_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>while (source->length != 0) {>>>do { 	isc_result_t _r = (base32_decode_char(&ctx, c)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base32_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);"
bind/lib/isc,base32.c,for,2,for (i = 0; i < tr->length; i++)>>>for (;;) {
bind/lib/isc,base64.c,while,12,"while (source->length > 2) {>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(wordbreak, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (mem_tobuffer(ctx->target, buf, n)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>while (!ctx.seen_end && (ctx.length != 0)) {>>>do { 	isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, 					      isc_tokentype_string, eol)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base64_decode_char(&ctx, tr->base[i])); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base64_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base64_decode_char(&ctx, c)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (base64_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);"
bind/lib/isc,base64.c,for,2,for (i = 0; i < tr->length; i++)>>>for (;;) {
bind/lib/isc,bitstring.c,while,1,while (n > 0) {
bind/lib/isc,bufferlist.c,while,2,while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {
bind/lib/isc,entropy.c,while,5,while (desired > 0 && result == ISC_R_SUCCESS) {>>>while (remain != 0) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {
bind/lib/isc,entropy.c,for,5,for (; len > 3; len -= 4) {>>>for (ns = 0; ns < 4; ns++)>>>for (ns = 4; ns < sq->nsamples; ns++)>>>for (ns = 0; ns < 4; ns++) {>>>for (i = 0; i < count; i++)
bind/lib/isc,hash.c,for,3,"for (i = 0; i < hctx->vectorlen; i += copylen, p += copylen) {>>>for (i = 0; i < keylen; i++)>>>for (i = 0; i < keylen; i++)"
bind/lib/isc,heap.c,while,1,while (i <= half_size) {
bind/lib/isc,heap.c,for,2,for (p = ((i) >> 1) ;>>>for (i = 1 ; i <= heap->last ; i++)
bind/lib/isc,hex.c,while,10,"while (source->length > 0) {>>>do { 	isc_result_t _r = (str_totext(buf, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (str_totext(wordbreak, target)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (mem_tobuffer(ctx->target, &num, 1)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>while (ctx.length != 0) {>>>do { 	isc_result_t _r = (isc_lex_getmastertoken(lexer, &token, 					      isc_tokentype_string, eol)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (hex_decode_char(&ctx, tr->base[i])); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (hex_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (hex_decode_char(&ctx, c)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);>>>do { 	isc_result_t _r = (hex_decode_finish(&ctx)); 	if (_r != ISC_R_SUCCESS) 		return (_r); 	} while (0);"
bind/lib/isc,hex.c,for,2,for (i = 0; i < tr->length; i++)>>>for (;;) {
bind/lib/isc,hmacmd5.c,for,2,for (i = 0; i < 64; i++)>>>for (i = 0; i < 64; i++)
bind/lib/isc,hmacsha.c,for,10,for (i = 0; i < ISC_SHA1_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA1_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA224_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA224_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA256_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA256_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA384_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA384_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA512_BLOCK_LENGTH; i++)>>>for (i = 0; i < ISC_SHA512_BLOCK_LENGTH; i++)
bind/lib/isc,httpd.c,while,38,do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>while (url != ((void *)0)) {>>>do { } while(0);>>>do { } while(0);>>>while ((httpd->recvbuf - (s) < (int)httpd->recvlen) && (httpd->recvbuf - (s) < 1024) &&>>>while (*p != '/' && *p != 0)>>>while (*p != '/' && *p != 0)>>>while (*p != '/' && *p != 0)>>>while ((httpd->recvbuf - (s) < (int)httpd->recvlen) && (httpd->recvbuf - (s) < 1024) &&>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>while (url != ((void *)0)) {>>>do { } while(0);>>>do { } while(0);>>>while (httpd != ((void *)0)) {>>>do { } while(0);>>>while (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {>>>while (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {>>>while (isc_buffer_availablelength(&httpd->headerbuffer) < 2) {>>>while (isc_buffer_availablelength(&httpd->headerbuffer) < needlen) {>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);>>>do { } while(0);
bind/lib/isc,inet_aton.c,for,2,for (;;) {>>>for (;;) {
bind/lib/isc,inet_pton.c,while,2,while ((ch = *src++) != '\0') {>>>while ((ch = *src++) != '\0') {
bind/lib/isc,inet_pton.c,for,1,for (i = 1; i <= n; i++) {
bind/lib/isc,iterated_hash.c,while,1,} while (n++ < iterations);
bind/lib/isc,lex.c,while,2,while (!EMPTY(lex->sources))>>>} while (!done);
bind/lib/isc,lfsr.c,while,3,while (byte--) {>>>while (skip--)>>>while (skip--)
bind/lib/isc,lfsr.c,for,1,for (bit = 0; bit < 7; bit++) {
bind/lib/isc,log.c,while,7,while ((message = ISC_LIST_HEAD(lctx->messages)) != ((void *)0)) {>>>while ((channel = ISC_LIST_HEAD(lcfg->channels)) != ((void *)0)) {>>>while ((item = ISC_LIST_HEAD(lcfg->channellists[i])) != ((void *)0)) {>>>while (isc_dir_read(&dir) == ISC_R_SUCCESS) {>>>while (--greatest >= (channel->destination.file.versions)) {>>>while (message != ((void *)0)) {>>>} while (1);
bind/lib/isc,log.c,for,12,for (i = 0; i < lcfg->channellist_count; i++)>>>for (catp = lctx->categories; catp->name != ((void *)0); )>>>for (catp = categories; catp->name != ((void *)0); catp++)>>>for (catp = lctx->categories; catp->name != ((void *)0); )>>>for (modp = lctx->modules; modp->name != ((void *)0); )>>>for (modp = modules; modp->name != ((void *)0); modp++)>>>for (modp = lctx->modules; modp->name != ((void *)0); )>>>for (channel = ISC_LIST_HEAD(lcfg->channels); channel != ((void *)0);>>>for (i = 0; i < lctx->category_count; i++) {>>>for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);>>>for (channel = ISC_LIST_HEAD(lctx->logconfig->channels);>>>for (i = greatest; i > 0; i--) {
bind/lib/isc,md5.c,while,2,} while (--words);>>>while (len >= 64) {
bind/lib/isc,mem.c,while,2,while (pool != ((void *)0)) {>>>while (mpctx->items != ((void *)0)) {
bind/lib/isc,mem.c,for,6,for (i = 0; i < (64 - 1); i++) {>>>for (i = 0; i < (frags - 1); i++) {>>>for (i = 0; i <= ctx->max_size; i++) {>>>for (i = 0; i < ctx->basic_table_count; i++)>>>for (i = 0; i <= ctx->max_size; i++) {>>>for (i = 0; i < mpctx->fillcount; i++) {
bind/lib/isc,mutexblock.c,while,1,while (i > 0U) {
bind/lib/isc,mutexblock.c,for,2,for (i = 0; i < count; i++) {>>>for (i = 0; i < count; i++) {
bind/lib/isc,netaddr.c,while,1,while ((c & 0x80) != 0 && nbits < 8) {
bind/lib/isc,netaddr.c,for,2,for (i = 0; i < ipbytes; i++) {>>>for (; i < ipbytes; i++) {
bind/lib/isc,ondestroy.c,while,1,while (eventp != ((void *)0)) {
bind/lib/isc,portset.c,while,2,} while (p++ < port_hi);>>>} while (p++ < port_hi);
bind/lib/isc,print.c,while,19,while (*format != '\0') {>>>} while (1);>>>while (pad > 0 && size > 1) {>>>while (*cp != '\0' && size > 1) {>>>while (zeropad > 0 && size > 1) {>>>while (*cp != '\0' && size > 1) {>>>while (pad > 0 && size > 1) {>>>while (n != 0 && *tp != '\0')>>>while (pad > 0 && size > 1) {>>>while (*cp != '\0' && size > 1) {>>>while (pad > 0 && size > 1) {>>>while (width-- > 0 && size > 1) {>>>while (pad > 0 && size > 1) {>>>while (zeropad > 0 && size > 1) {>>>while (*cp != '\0' && size > 1) {>>>while (pad > 0 && size > 1) {>>>while (pad > 0 && size > 1) {>>>while (*cp != ' ' && size > 1) {>>>while (pad > 0 && size > 1) {
bind/lib/isc,condition.c,while,1,} while (presult == 4);
bind/lib/isc,radix.c,while,5,while (Xrn != NULL) {>>>while (node->bit < bitlen) {>>>while (cnt-- > 0) {>>>while (node->bit < bitlen || node->prefix == NULL) {>>>while (parent != NULL && parent->bit >= differ_bit) {
bind/lib/isc,radix.c,for,2,for (i = 0; i*8 < check_bit; i++) {>>>for (j = 0; j < 8; j++) {
bind/lib/isc,ratelimiter.c,while,2,while (pertic != 0) {>>>while ((ev = ISC_LIST_HEAD(rl->pending)) != NULL) {
bind/lib/isc,result.c,for,1,for (table = ISC_LIST_HEAD(tables);
bind/lib/isc,sha1.c,while,1,while ((context->count[0] & 504) != 448)
bind/lib/isc,sha1.c,for,3,for (; i + 63 < len; i += 64)>>>for (i = 0; i < 8; i++) {>>>for (i = 0; i < 20; i++)
bind/lib/isc,sha2.c,while,6,} while (j < 16);>>>} while (j < 64);>>>while (len >= ISC_SHA256_BLOCK_LENGTH) {>>>} while (j < 16);>>>} while (j < 80);>>>while (len >= ISC_SHA512_BLOCK_LENGTH) {
bind/lib/isc,sha2.c,for,7,for (j = 0; j < 8; j++) {>>>for (j = 0; j < 8; j++) {>>>for (j = 0; j < 6; j++) {>>>for (i = 0; i < ISC_SHA224_DIGESTLENGTH; i++) {>>>for (i = 0; i < ISC_SHA256_DIGESTLENGTH; i++) {>>>for (i = 0; i < ISC_SHA512_DIGESTLENGTH; i++) {>>>for (i = 0; i < ISC_SHA384_DIGESTLENGTH; i++) {
bind/lib/isc,stats.c,for,1,for (i = 0; i < stats->ncounters; i++) {
bind/lib/isc,string.c,while,6,while (*s != 0 && isascii(*s&0xff) && isspace(*s&0xff))>>>while ((c = *s) != 0) {>>>} while (--n != 0U);>>>while (*s++)>>>while (n-- != 0U && *d != '\0')>>>while (*s != '\0') {
bind/lib/isc,string.c,for,2,for (s = string; (sc = *s) != '\0'; s++)>>>for (d = delim; (dc = *d) != '\0'; d++)
bind/lib/isc,strtoul.c,while,1,} while (isspace(c));
bind/lib/isc,strtoul.c,for,1,"for (acc = 0, any = 0;; c = *s++) {"
bind/lib/isc,symtab.c,for,11,"for (i = 0; i < size; i++)>>>for (i = 0; i < symtab->size; i++) {>>>for (elt = HEAD(symtab->table[i]); elt != NULL; elt = nelt) {>>>for (s = key; *s != '\0'; s++) {>>>for (s = key; *s != '\0'; s++) {>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};>>>for (i = 0; i < newsize; i++)>>>for (i = 0; i < symtab->size; i++) {>>>for (elt = HEAD(symtab->table[i]); elt != NULL; elt = nelt) {>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = HEAD((symtab)->table[ bucket]);  elt != NULL;  elt = NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};"
bind/lib/isc,task.c,while,3,while (!((manager)->exiting && EMPTY((manager)->tasks))) {>>>} while (!done);>>>while (isc__taskmgr_ready((isc_taskmgr_t *)manager))
bind/lib/isc,task.c,for,5,for (event = TAIL(task->on_shutdown);>>>for (event = HEAD(task->events); event != NULL; event = next_event) {>>>for (event = HEAD(events); event != NULL; event = next_event) {>>>for (curr_event = HEAD(task->events);>>>for (task = HEAD(manager->tasks);
bind/lib/isc,taskpool.c,for,6,for (i = 0; i < ntasks; i++)>>>for (i = 0; i < ntasks; i++) {>>>for (i = 0; i < pool->ntasks; i++) {>>>for (i = pool->ntasks; i < size; i++) {>>>for (i = 0; i < pool->ntasks; i++) {>>>for (i = 0; i < pool->ntasks; i++) {
bind/lib/isc,hash_test.c,while,12,while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {>>>while (testcase->input != ((void *)0) && testcase->result != ((void *)0)) {
bind/lib/isc,hash_test.c,for,7,for (i = 0; i < len; i++) {>>>for(i = 0; i < testcase->repeats; i++) {>>>for(i = 0; i < testcase->repeats; i++) {>>>for(i = 0; i < testcase->repeats; i++) {>>>for(i = 0; i < testcase->repeats; i++) {>>>for(i = 0; i < testcase->repeats; i++) {>>>for(i = 0; i < testcase->repeats; i++) {
bind/lib/isc,isctest.c,while,10,"do { 		result = (isc_taskmgr_create(mctx, ncpus, 0, &taskmgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_timermgr_create(mctx, &timermgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_socketmgr_create(mctx, &socketmgr)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_mem_create(0, 0, &mctx)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_entropy_create(mctx, &ectx)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_hash_create(mctx, ectx, 255)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_create(mctx, &lctx, &logconfig)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_createchannel(logconfig, ""stderr"", 					    ISC_LOG_TOFILEDESC, 					    ISC_LOG_DYNAMIC, 					    &destination, 0)); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (isc_log_usechannel(logconfig, ""stderr"", ((void *)0), ((void *)0))); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);>>>do { 		result = (create_managers()); 		if (result != ISC_R_SUCCESS) 			goto cleanup; 	} while (0);"
bind/lib/isc,socket_test.c,while,2,while (!completion->done && i++ < 5000) {>>>while (isc__taskmgr_ready(taskmgr))
bind/lib/isc,socket_test.c,for,7,waitfor(completion_t *completion) {>>>waitfor(&completion);>>>waitfor(&completion);>>>waitfor(&completion);>>>waitfor(&completion);>>>waitfor(&completion);>>>waitfor(&completion);
bind/lib/isc,symtab_test.c,for,5,for (i = 0; i < 1024; i++) {>>>for (i = 0; i < 1024; i++) {>>>for (i = 0; i < 1024; i++) {>>>for (i = 0; i < 1024; i++) {>>>for (i = 0; i < 1024; i++) {
bind/lib/isc,task_test.c,while,6,while ((a == 0 || b == 0) && i++ < 5000) {>>>while (isc__taskmgr_ready(taskmgr))>>>while ((a == 0 || b == 0 || c == 0 || d == 0 || e == 0) && i++ < 5000) {>>>while (isc__taskmgr_ready(taskmgr))>>>while ((a == -1 || b == -1 || c == -1 || d == -1 || e == -1) &&>>>while (isc__taskmgr_ready(taskmgr))
bind/lib/isc,timer.c,while,1,while (manager->nscheduled > 0 && !done) {
bind/lib/isc,app.c,while,1,while (!ctx->want_shutdown) {
bind/lib/isc,app.c,for,1,for (event = ISC_LIST_HEAD(ctx->on_run);
bind/lib/isc,dir.c,while,2,while (*p != '\0') {>>>} while (1);
bind/lib/isc,dir.c,for,1,for (x = templet + strlen(templet) - 1; *x == 'X' && x >= templet;
bind/lib/isc,entropy.c,while,12,while (desired > 0 && result == ISC_R_SUCCESS) {>>>while (remain != 0) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {>>>while (desired > 0) {>>>while (desired > 0) {>>>while ((remaining != 0) && (source != ((void *)0))) {>>>while (source != ((void *)0)) {>>>do { int __fd = (fd); ((  &reads)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>do { int __fd = (fd); ((  &writes)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>do { int __fd = (fd); ((  &reads)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);
bind/lib/isc,entropy.c,for,6,for (; len > 3; len -= 4) {>>>for (ns = 0; ns < 4; ns++)>>>for (ns = 4; ns < sq->nsamples; ns++)>>>for (ns = 0; ns < 4; ns++) {>>>for (i = 0; i < count; i++)>>>for (nsource = 0; nsource < ent->nsources; nsource++) {
bind/lib/isc,file.c,while,6,"while (*cp != '\0')>>>while (cp >= templet && *cp == 'X') {>>>while (link(file, templet) == -1) {>>>while (*cp != '\0')>>>while (cp >= templet && *cp == 'X') {>>>while ((fd = open(templet, 0x0002|0x0200|0x0800, mode)) == -1) {"
bind/lib/isc,file.c,for,2,for (cp = x;;) {>>>for (cp = x;;) {
bind/lib/isc,ifiter_ioctl.c,for,2,for (;;) {>>>for (i = 0; i < 16; i++) {
bind/lib/isc,ifiter_sysctl.c,for,1,for (i = 0; i < 8; i++)
bind/lib/isc,interfaceiter.c,for,4,for (;;) {>>>for (i = 0; i < 16; i++) {>>>for (;;) {>>>for (;;) {
bind/lib/isc,socket.c,while,19,do { int __fd = (fd); ((  manager->read_fds)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>do { int __fd = (fd); ((  manager->write_fds)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>do { int __fd = (fd); ((  manager->read_fds)->fds_bits[__fd/(sizeof(__int32_t) * 8)] &= ~(1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>do { int __fd = (fd); ((  manager->write_fds)->fds_bits[__fd/(sizeof(__int32_t) * 8)] &= ~(1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0) && actual_count > 0U) {>>>while (dev != ((void *)0)) {>>>} while (dev != ((void *)0));>>>while (dev != ((void *)0)) {>>>while (--i >= 0)>>>while (!ISC_LIST_EMPTY(manager->socklist)) {>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {>>>while (dev != ((void *)0)) {>>>while (dev != ((void *)0)) {>>>while (dev != ((void *)0)) {
bind/lib/isc,socket.c,for,6,for (i = fd - 1; i >= 0; i--) {>>>for (i = 0; i < maxfd; i++) {>>>for (i = 0; i < 1; i++) {>>>for (i = 0; i < 1; i++)>>>for (i = 0; i < (int)manager->maxsocks; i++)>>>for (i = 0; i < 1; i++)
bind/lib/isc,stdtime.c,while,2,} while (tv->tv_usec < 0);>>>} while (tv->tv_usec >=1000000);
bind/lib/isc,syslog.c,for,1,for (i = 0; facilities[i].strval != ((void *)0); i++) {
bind/lib/isc,time.c,while,2,} while (tv->tv_usec < 0);>>>} while (tv->tv_usec >=1000000);
bind/lib/isc,app.c,while,1,while (!want_shutdown) {
bind/lib/isc,app.c,for,1,for (event = ISC_LIST_HEAD(on_run);
bind/lib/isc,condition.c,while,1,while (threadcond != NULL) {
bind/lib/isc,condition.c,for,2,for (threadcond = ISC_LIST_HEAD(cond->threadlist);>>>for (threadcond = ISC_LIST_HEAD(cond->threadlist);
bind/lib/isc,dir.c,while,2,while (*p != '\0') {>>>} while (1);
bind/lib/isc,dir.c,for,1,for (x = templet + strlen(templet) - 1; *x == 'X' && x >= templet;
bind/lib/isc,entropy.c,while,7,while (desired > 0 && result == ISC_R_SUCCESS) {>>>while (remain != 0) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {>>>while (source != ((void *)0)) {>>>while (desired > 0) {>>>while ((remaining != 0) && (source != ((void *)0))) {
bind/lib/isc,entropy.c,for,6,for (; len > 3; len -= 4) {>>>for (ns = 0; ns < 4; ns++)>>>for (ns = 4; ns < sq->nsamples; ns++)>>>for (ns = 0; ns < 4; ns++) {>>>for (i = 0; i < count; i++)>>>for (nsource = 0; nsource < ent->nsources; nsource++) {
bind/lib/isc,file.c,while,1,while (*--trv == 'X') {
bind/lib/isc,file.c,for,3,for (start = trv + 1;; --trv) {>>>for (;;) {>>>for (trv = start;;) {
bind/lib/isc,interfaceiter.c,for,4,for (;;) {>>>for (;;) {>>>for (i = 0; i< 16; i++)>>>for (;;) {
bind/lib/isc,once.c,while,1,while (controller->status == ISC_ONCE_INIT_NEEDED) {
bind/lib/isc,socket.c,while,62,while (ldev != ((void *)0)) {>>>while (ldev != ((void *)0)) {>>>while (ndev != ((void *)0)) {>>>do { (sock)->state = ( SOCK_CLOSED); (sock)->state_lineno = 597; } while (0);>>>do {} while (0);>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0)) {>>>while (buffer != ((void *)0) && sock->recvbuf.remaining > 0) {>>>while (sock->recvbuf.remaining > 0 && !ISC_LIST_EMPTY(sock->recv_list)) {>>>do { (sock)->state = ( SOCK_DATA); (sock)->state_lineno = 1430; } while (0);>>>do { (sock)->state = ( SOCK_INITIALIZED); (sock)->state_lineno = 1471; } while (0);>>>while (dev != ((void *)0)) {>>>while (nev != ((void *)0)) {>>>do {} while (0);>>>do { (sock)->state = ( SOCK_CLOSED); (sock)->state_lineno = 1677; } while (0);>>>do { (sock)->state = ( SOCK_OPEN); (sock)->state_lineno = 1802; } while (0);>>>do {} while (0);>>>do {} while (0);>>>do { (sock)->state = ( SOCK_CLOSED); (sock)->state_lineno = 1895; } while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do { (nsock)->state = ( SOCK_OPEN); (nsock)->state_lineno = 2079; } while (0);>>>do {} while (0);>>>do { (sock)->state = ( SOCK_CLOSED); (sock)->state_lineno = 2129; } while (0);>>>do {} while (0);>>>do {} while (0);>>>while (!ISC_LIST_EMPTY(sock->recv_list)) {>>>do {} while (0);>>>do {} while (0);>>>while (buffer != ((void *)0)) {>>>while (ldev != ((void *)0) && ldev != dev)>>>while (ldev != ((void *)0) && ldev != dev)>>>while (TRUE) {>>>do {} while (0);>>>while (!ISC_LIST_EMPTY(manager->socklist)) {>>>do {} while (0);>>>while (buffer != ((void *)0)) {>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>while (buffer != ((void *)0)) {>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do { (sock)->state = ( SOCK_LISTEN); (sock)->state_lineno = 3292; } while (0);>>>do {} while (0);>>>do { (nsock)->state = ( SOCK_ACCEPT); (nsock)->state_lineno = 3377; } while (0);>>>do {} while (0);>>>do { (sock)->state = ( SOCK_CONNECT); (sock)->state_lineno = 3516; } while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>do {} while (0);>>>while (dev != ((void *)0)) {>>>while (dev != ((void *)0)) {>>>while (dev != ((void *)0)) {>>>do { (sock)->state = ( SOCK_CLOSED); (sock)->state_lineno = 3725; } while (0);>>>do {} while (0);
bind/lib/isc,socket.c,for,3,for (i = 0; i < manager->maxIOCPThreads; i++) {>>>for (i = 0; i < total_threads; i++) {>>>for (i = 0; i < manager->maxIOCPThreads; i++) {
bind/lib/isc,syslog.c,for,1,for (i = 0; facilities[i].strval != ((void *)0); i++) {
bind/lib/isccc,alist.c,while,2,while (alist != ((void *)0)) {>>>while (rest != ((void *)0)) {
bind/lib/isccc,alist.c,for,1,for (elt = isccc_alist_first(sexpr);
bind/lib/isccc,cc.c,while,4,while (list != ((void *)0)) {>>>while (!REGION_EMPTY(*source)) {>>>while (!REGION_EMPTY(*source)) {>>>while ((c = *str++) != '\0') {
bind/lib/isccc,cc.c,for,1,for (elt = isccc_alist_first(alist);
bind/lib/isccc,sexpr.c,while,2,while (curr != r->rend) {>>>} while (sexpr != ((void *)0));
bind/lib/isccc,sexpr.c,for,2,for (i = 0; i < size; i++)>>>for (last = l1; (last)->value.as_dottedpair.cdr != ((void *)0); last = (last)->value.as_dottedpair.cdr)
bind/lib/isccc,symtab.c,for,10,"for (i = 0; i < size; i++)>>>for (i = 0; i < symtab->size; i++) {>>>for (elt = ISC_LIST_HEAD(symtab->table[i]);>>>for (s = key; *s != '\0'; s++) {>>>for (s = key; *s != '\0'; s++) {>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};>>>bucket = hash(( key), (symtab)->case_sensitive) % (symtab)->size; 	if ((symtab)->case_sensitive) { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcmp( elt->key, ( key)) == 0) 				break; 		} 	} else { 		for ( elt = ISC_LIST_HEAD((symtab)->table[ bucket]); 		      elt != ((void *)0); 		      elt = ISC_LIST_NEXT( elt, link)) { 			if ((( type) == 0 ||  elt->type == ( type)) && 			    strcasecmp( elt->key, ( key)) == 0) 				break; 		} 	};>>>for (i = 0; i < symtab->size; i++) {>>>for (elt = ISC_LIST_HEAD(symtab->table[i]);"
bind/lib/isccfg,aclconf.c,for,5,for (dacl = ISC_LIST_HEAD(actx->named_acl_cache);>>>for (elt = cfg_list_first(acls);>>>for (dacl = ISC_LIST_HEAD(ctx->named_acl_cache);>>>for (elt = cfg_list_first(caml);>>>for (elt = cfg_list_first(caml);
bind/lib/isccfg,namedconf.c,while,84,"do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_void(pctx, ((void *)0), &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_ustring, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_uint32(pctx, ((void *)0), ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, ISC_LEXOPT_NUMBER | ISC_LEXOPT_CNUMBER));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (parse_port(pctx, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_tuple(pctx, &cfg_type_porttuple, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (parse_port(pctx, &obj->value.tuple[0]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (parse_port(pctx, &obj->value.tuple[1]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_tuple(pctx, type, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[0].type, &obj->value.tuple[0]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[1].type, &obj->value.tuple[1]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_void(pctx, ((void *)0), &obj->value.tuple[2]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[2].type, &obj->value.tuple[2]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { if ((obj) != ((void *)0)) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_peektoken(pctx, ISC_LEXOPT_NUMBER | ISC_LEXOPT_CNUMBER));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_uint32, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_void, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (parse_unitstring((pctx->token.value.as_textregion.base), &val));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_uint64, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (kw->type->parse(pctx, kw->type, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_void(pctx, ((void *)0), &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_enum(pctx, enumtype, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, othertype, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_ustring, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_void, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_rawaddr(pctx, *flagp, 							&netaddr));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_rawport(pctx, 							CFG_ADDR_WILDOK, 							&port));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_querysource, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { if ((obj) != ((void *)0)) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_peektoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_keyref, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_netprefix(pctx, ((void *)0), ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_astring(pctx, ((void *)0), ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_bracketed_aml, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_negated, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_astring, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_special(pctx, '}'));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_astring, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_void, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, ISC_LEXOPT_NUMBER));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_uint32(pctx, ((void *)0), ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_uint32, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_loglevel, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_tuple(pctx, type, &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[0].type, &obj->value.tuple[0]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_peektoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_gettoken(pctx, 0));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[1].type, 					    &obj->value.tuple[1]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[2].type, 					    &obj->value.tuple[2]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_void(pctx, ((void *)0), &obj->value.tuple[1]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_void(pctx, ((void *)0), &obj->value.tuple[2]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { if ((obj) != ((void *)0)) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_peektoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_sockaddr(pctx, &cfg_type_sockaddr, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_create_tuple(pctx, &cfg_type_nameport, 					       &obj));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[0].type, 					    &obj->value.tuple[0]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_obj(pctx, fields[1].type, 					    &obj->value.tuple[1]));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { if ((obj) != ((void *)0)) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_peektoken(pctx, CFG_LEXOPT_QSTRING));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_sockaddr(pctx, &cfg_type_sockaddr, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { result = (cfg_parse_astring(pctx, &cfg_type_astring, ret));							if (result != ISC_R_SUCCESS) goto cleanup;		} while (0);>>>do { if ((obj) != ((void *)0)) cfg_obj_destroy(pctx, &(obj)); } while (0);"
bind/lib/isccfg,namedconf.c,for,3,for (p = kw->type->of; *p != ((void *)0); p++) {>>>for (;;) {>>>for (;;) {
bind/lib/isccfg,parser.c,while,101,"while (indent > 0) {>>>do { result = (cfg_create_obj(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_tuple(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_obj(pctx, f->type, &obj->value.tuple[i])); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { if ((obj->value.tuple[i]) != NULL) cfg_obj_destroy(pctx, &(obj->value.tuple[i])); } while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (isc_lex_create(pctx->mctx, 1024, &pctx->lexer)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, &cfg_type_filelist, &pctx->open_files)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, &cfg_type_filelist, &pctx->closed_files)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((pctx->open_files) != NULL) cfg_obj_destroy(pctx, &(pctx->open_files)); } while (0);>>>do { if ((pctx->closed_files) != NULL) cfg_obj_destroy(pctx, &(pctx->closed_files)); } while (0);>>>do { result = (create_string(pctx, filename, &cfg_type_qstring, &stringobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (create_listelt(pctx, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((stringobj) != NULL) cfg_obj_destroy(pctx, &(stringobj)); } while (0);>>>do { result = (parse_eof(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (parser_openfile(pctx, filename)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse2(pctx, type, ret)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (isc_lex_openbuffer(pctx->lexer, buffer)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse2(pctx, type, ret)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((pctx->open_files) != NULL) cfg_obj_destroy(pctx, &(pctx->open_files)); } while (0);>>>do { if ((pctx->closed_files) != NULL) cfg_obj_destroy(pctx, &(pctx->closed_files)); } while (0);>>>do { result = (cfg_gettoken(pctx, ISC_LEXOPT_NUMBER | ISC_LEXOPT_CNUMBER)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_uint32, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, CFG_LEXOPT_QSTRING)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_getstringtoken(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_ustring(pctx, NULL, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (check_enum(pctx, obj, type->of)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_boolean, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, type, obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (create_listelt(pctx, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, listtype, &listobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_peektoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_listelt(pctx, listof, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_semicolon(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((listobj) != NULL) cfg_obj_destroy(pctx, &(listobj)); } while (0);>>>do { result = (cfg_parse_special(pctx, '{')); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_list(pctx, type, ret)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_special(pctx, '}')); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, listtype, &listobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_peektoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_listelt(pctx, listof, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((listobj) != NULL) cfg_obj_destroy(pctx, &(listobj)); } while (0);>>>do { result = (create_map(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_qstring, &includename)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_semicolon(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parser_openfile(pctx, includename-> 					      value.string.base)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_obj(pctx, &cfg_type_unsupported, &eltobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_semicolon(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, 						  &cfg_type_implicitlist, 						  &listobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_listelt(pctx, clause->type, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_semicolon(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_symtab_elt(pctx, clause->name, 						       clause->type, 						       obj->value.map.symtab, 						       callback)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (parse_semicolon(pctx)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((value) != NULL) cfg_obj_destroy(pctx, &(value)); } while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { if ((eltobj) != NULL) cfg_obj_destroy(pctx, &(eltobj)); } while (0);>>>do { if ((includename) != NULL) cfg_obj_destroy(pctx, &(includename)); } while (0);>>>do { result = (cfg_parse_obj(pctx, elttype, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (pctx->callback(name, obj, pctx->callbackarg)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (isc_symtab_define(symtab, name, 				1, symval, 				isc_symexists_reject)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_parse_special(pctx, '{')); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_mapbody(pctx, type, ret)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_special(pctx, '}')); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_obj(pctx, nametype, &idobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_map(pctx, type, &mapobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((idobj) != NULL) cfg_obj_destroy(pctx, &(idobj)); } while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_token, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, CFG_LEXOPT_QSTRING)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_list(pctx, type, &listobj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_peektoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_listelt(pctx, &cfg_type_token, &elt)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((listobj) != NULL) cfg_obj_destroy(pctx, &(listobj)); } while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, ISC_LEXOPT_NUMBER)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_rawaddr(pctx, flags, &netaddr)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_parse_rawaddr(pctx, CFG_ADDR_V4OK | CFG_ADDR_V4PREFIXOK | 				CFG_ADDR_V6OK, &netaddr)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_peektoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, ISC_LEXOPT_NUMBER)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, &cfg_type_netprefix, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_rawaddr(pctx, flags, &netaddr)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_peektoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_gettoken(pctx, 0)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_parse_rawport(pctx, flags, &port)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj) != NULL) cfg_obj_destroy(pctx, &(obj)); } while (0);>>>do { result = (cfg_gettoken(pctx, options)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (cfg_create_obj(pctx, type, &obj)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { result = (isc_symtab_create(pctx->mctx, 5,  				map_symtabitem_destroy, 				pctx, ISC_FALSE, &symtab)); 							if (result != ISC_R_SUCCESS) goto cleanup; 		} while (0);>>>do { if ((obj->value.map.id) != NULL) cfg_obj_destroy(pctx, &(obj->value.map.id)); } while (0);"
bind/lib/isccfg,parser.c,for,23,"for (f = fields; f->name != NULL; f++)>>>for (f = fields, i = 0; f->name != NULL; f++, i++)>>>for (f = fields, i = 0; f->name != NULL; f++, i++)>>>for (f = fields, i = 0; f->name != NULL; f++, i++) {>>>for (f = fields; f->name != NULL; f++) {>>>for (f = fields, i = 0; f->name != NULL; f++, i++) {>>>for (f = fields, i = 0; f->name != NULL; f++, i++) {>>>for (p = enums; *p != NULL; p++) {>>>for (p = type->of; *p != NULL; p++) {>>>for (elt = ISC_LIST_HEAD(obj->value.list);>>>for (;;) {>>>for (elt = ISC_LIST_HEAD(*list);>>>for (;;) {>>>for (elt = ISC_LIST_HEAD(*list);>>>for (elt = cfg_list_first(obj);>>>for (;;) {>>>for (clauseset = clausesets; *clauseset != NULL; clauseset++) {>>>for (elt = ISC_LIST_HEAD(*list);>>>for (clauseset = type->of; *clauseset != NULL; clauseset++) {>>>for (p = flagtexts; p->flag != 0; p++) {>>>for (clauseset = type->of; *clauseset != NULL; clauseset++) {>>>for (;;) {>>>for (i = 0; i < 3; i++) {"
bind/lib/lwres,context.c,while,2,"do { 	 ret = fcntl(s, 3, 0); 	if ( ret != -1) { 		 ret |= 0x0004; 		 ret = fcntl(s, 4,  ret); 	} } while (0);>>>do { int __fd = (ctx->sock); ((  &readfds)->fds_bits[__fd/(sizeof(__int32_t) * 8)] |= (1<<(__fd % (sizeof(__int32_t) * 8)))); } while(0);"
bind/lib/lwres,getaddrinfo.c,while,15,while (order != NULL) {>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>while (addr != NULL) {>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_FAIL);					if (result != 0) goto cleanup;		} while (0);>>>while (addr != NULL) {>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (EAI_MEMORY);					if (result != 0) goto cleanup;		} while (0);>>>while (ai != NULL) {>>>while (oai != NULL) {
bind/lib/lwres,getaddrinfo.c,for,3,for (i = 0; i < 2; i++) {>>>for (s = string; *s != '\0'; s++) {>>>for (d = delim; (dc = *d) != '\0'; d++)
bind/lib/lwres,gethost.c,for,4,"for (i = 0; he->h_addr_list[i]; i++, nptr++) {>>>for (i = 0; he->h_aliases[i]; i++, nptr++) {>>>for (i = 0; he->h_addr_list[i]; i++, ptr++) {>>>for (i = 0; he->h_aliases[i]; i++) {"
bind/lib/lwres,getipnode.c,while,12,while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (*cpp != ((void *)0)) {>>>while (addr != ((void *)0)) {
bind/lib/lwres,getipnode.c,for,6,for (i = 0; i < addr->naliases; i++) {>>>for (i = 0; he->h_addr_list[i] != ((void *)0); i++)>>>for (i = 0; he->h_aliases[i] != ((void *)0); i++)>>>for (i = 0; i < name->naliases; i++) {>>>for (i = 0; he->h_addr_list[i] != ((void *)0); i++)>>>for (i = 0; he->h_aliases[i] != ((void *)0); i++)
bind/lib/lwres,getnameinfo.c,while,11,do { result = (7);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (5);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (6);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (3);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (3);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (4);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (3);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (3);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (2);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (2);					if (result != 0) goto cleanup;		} while (0);>>>do { result = (3);					if (result != 0) goto cleanup;		} while (0);
bind/lib/lwres,getnameinfo.c,for,1,for (i = 0; afdl[i].a_af; i++)
bind/lib/lwres,getrrset.c,for,4,for (i = 0; i < rrset->rri_nrdatas; i++) {>>>for (i = 0; i < rrset->rri_nsigs; i++) {>>>for (i = 0; i < rrset->rri_nrdatas; i++) {>>>for (i = 0; i < rrset->rri_nsigs; i++) {
bind/lib/lwres,lwconfig.c,while,7,while (ch != '\n' && ch != (-1))>>>while (ch != '\n' && ch != (-1) && isspace((unsigned char)ch))>>>} while (1);>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>} while (1);
bind/lib/lwres,lwconfig.c,for,12,for (i = 0; i < LWRES_CONFMAXNAMESERVERS; i++)>>>for (i = 0; i < LWRES_CONFMAXSEARCH; i++)>>>for (i = 0; i < LWRES_CONFMAXSORTLIST; i++) {>>>for (i = 0; i < confdata->nsnext; i++)>>>for (i = 0; i < confdata->searchnxt; i++) {>>>for (i = 0; i < LWRES_CONFMAXSORTLIST; i++) {>>>for (i = 0; i < LWRES_CONFMAXSEARCH; i++) {>>>for (idx = 0; idx < LWRES_CONFMAXSEARCH; idx++) {>>>for (i = 0; i < confdata->nsnext; i++) {>>>for (i = 0; i < confdata->lwnext; i++) {>>>for (i = 0; i < confdata->searchnxt; i++)>>>for (i = 0; i < confdata->sortlistnxt; i++) {
bind/lib/lwres,lwinetaton.c,for,2,for (;;) {>>>for (;;) {
bind/lib/lwres,lwinetpton.c,while,2,while ((ch = *src++) != '\0') {>>>while ((ch = *src++) != '\0') {
bind/lib/lwres,lwinetpton.c,for,1,for (i = 1; i <= n; i++) {
bind/lib/lwres,lwres_gabn.c,while,4,while (addr != ((void *)0)) {>>>while (addr != ((void *)0)) {>>>while (addr != ((void *)0)) {>>>while (addr != ((void *)0)) {
bind/lib/lwres,lwres_gabn.c,for,5,for (x = 0; x < req->naliases; x++)>>>for (x = 0; x < req->naliases; x++) {>>>for (x = 0; x < naddrs; x++) {>>>for (x = 0; x < gabn->naliases; x++) {>>>for (x = 0; x < gabn->naddrs; x++) {
bind/lib/lwres,lwres_gnba.c,for,3,for (x = 0; x < req->naliases; x++)>>>for (x = 0; x < req->naliases; x++) {>>>for (x = 0; x < gnba->naliases; x++) {
bind/lib/lwres,lwres_grbn.c,for,6,for (x = 0; x < req->nrdatas; x++)>>>for (x = 0; x < req->nsigs; x++)>>>for (x = 0; x < req->nrdatas; x++) {>>>for (x = 0; x < req->nsigs; x++) {>>>for (x = 0; x < grbn->nrdatas; x++) {>>>for (x = 0; x < grbn->nsigs; x++) {
bind/lib/lwres,print.c,while,19,while (*format != '\0') {>>>} while (1);>>>while (pad > 0 && size > 1U) {>>>while (*cp != '\0' && size > 1U) {>>>while (zeropad > 0 && size > 1U) {>>>while (*cp != '\0' && size > 1U) {>>>while (pad > 0 && size > 1U) {>>>while (n != 0U && *tp != '\0')>>>while (pad > 0 && size > 1U) {>>>while (*cp != '\0' && size > 1U) {>>>while (pad > 0 && size > 1U) {>>>while (width-- > 0U && size > 1U) {>>>while (pad > 0 && size > 1U) {>>>while (zeropad > 0 && size > 1U) {>>>while (*cp != '\0' && size > 1U) {>>>while (pad > 0 && size > 1U) {>>>while (pad > 0 && size > 1U) {>>>while (*cp != ' ' && size > 1U) {>>>while (pad > 0 && size > 1U) {
bind/lib/lwres,strtoul.c,while,2,} while (isspace(c));>>>do { 		union { __const void *k; void *v; } _u; 		_u.k = any ? s - 1 : nptr; 		 *endptr = _u.v; 	} while (0);
bind/lib/lwres,strtoul.c,for,1,"for (acc = 0, any = 0;; c = *s++) {"
bind/lib/lwres,lwconfig.c,while,9,while (ch != '\n' && ch != (-1))>>>while (ch != '\n' && ch != (-1) && isspace((unsigned char)ch))>>>} while (1);>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>while (strlen(word) > 0U) {>>>} while (1);>>>while (cp != ((void *)0)) {>>>while (pIPAddr) {
bind/lib/lwres,lwconfig.c,for,12,for (i = 0; i < LWRES_CONFMAXNAMESERVERS; i++)>>>for (i = 0; i < LWRES_CONFMAXSEARCH; i++)>>>for (i = 0; i < LWRES_CONFMAXSORTLIST; i++) {>>>for (i = 0; i < confdata->nsnext; i++)>>>for (i = 0; i < confdata->searchnxt; i++) {>>>for (i = 0; i < LWRES_CONFMAXSORTLIST; i++) {>>>for (i = 0; i < LWRES_CONFMAXSEARCH; i++) {>>>for (idx = 0; idx < LWRES_CONFMAXSEARCH; idx++) {>>>for (i = 0; i < confdata->nsnext; i++) {>>>for (i = 0; i < confdata->lwnext; i++) {>>>for (i = 0; i < confdata->searchnxt; i++)>>>for (i = 0; i < confdata->sortlistnxt; i++) {
bind/lib/tests,t_api.c,while,13,"while ((c = isc_commandline_parse(argc, argv, "":at:c:d:n:huxq:b:""))>>>while (pts->pfv != ((void *)0)) {>>>while (*pts->pfv != ((void *)0)) {>>>while (deadpid != T_pid) {>>>while (*p != ((void *)0)) {>>>while (n < 256) {>>>while (*p != ((void *)0)) {>>>while ((c = fgetc(fp)) != (-1)) {>>>while (pmap->text != ((void *)0)) {>>>while (pmap->text != ((void *)0)) {>>>while ((p = strtok(line, ""\t"")) && (cnt < 16)) {>>>while (pts->func_name) {>>>while ((p = t_fgetbs(fp)) != ((void *)0)) {"